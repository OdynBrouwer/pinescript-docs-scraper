## Introduction
Pine ScriptÂ® strings are immutable values containing sequences of up to 40,960 encoded characters, such as letters, digits, symbols, spaces, control characters, or other Unicode characters and code points. Strings allow scripts to represent a wide range of data as character patterns and human-readable text.
Pine scripts use strings for several purposes, such as defining titles, expressing symbol and timeframe information, setting the contexts of data requests, creating alert and debug messages, and displaying text on the chart. The specialized functions in the `str.*` namespace provide convenient ways to construct strings, create modified copies of other strings, and inspect or extract substrings.
This page explains how Pine strings work, and how to construct, inspect, and modify strings using the available `str.*()` functions.
NoteWe use the format _â€œU+XXXXâ€_ throughout our documentation when referring to characters and code points in the Unicode Standard.

## Literal strings
Literal strings in Pine are character sequences enclosed by two _ASCII_ quotation marks (`"`) or apostrophes (`'`). For example, this code snippet declares two variables with equivalent literal strings containing the text `Hello world!`:
Pine ScriptÂ®
Copied
`//@variableÂ AÂ literalÂ stringÂ containingÂ `HelloÂ world!`.Â UsesÂ theÂ `"`Â characterÂ asÂ theÂ enclosingÂ delimiter.Â   
stringÂ hello1Â =Â "HelloÂ world!"  
//@variableÂ AÂ literalÂ stringÂ containingÂ `HelloÂ world!`.Â UsesÂ theÂ `'`Â characterÂ asÂ theÂ enclosingÂ delimiter.Â   
stringÂ hello2Â =Â 'HelloÂ world!'  
`
The `"` or `'` enclosing delimiters in a literal string definition are _not_ parts of the specified character sequence. They only mark the sequenceâ€™s start and end boundaries in the code. These characters _do not_ appear in outputs of Pine Logs or drawing objects that display â€œstringâ€ values.
This example calls the log.info() function on the first bar to display the contents of the literal value `"Hello world!"` in the Pine Logs pane. The message in the pane displays the `Hello world!` text only, without the `"` characters:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("LiteralÂ stringsÂ demo")Â //Â TheÂ script'sÂ displayedÂ titleÂ doesÂ notÂ includeÂ theÂ quotationÂ marks.  
  
ifÂ barstate.isfirst  
Â Â Â Â //Â LogÂ "HelloÂ world!"Â onÂ theÂ firstÂ bar.Â TheÂ loggedÂ textÂ doesÂ notÂ includeÂ `"`Â characters.Â   
Â Â Â Â log.info("HelloÂ world!")  
`
Note that:
  * The script also uses a literal string to define the `title` argument of the indicator() declaration statement.
  * Only the `"` and `'` ASCII characters are valid enclosing delimiters for literal strings. Other Unicode characters, such as U+FF02 (Fullwidth Quotation Mark), are not allowed as enclosing delimiters.
  * The timestamp in square brackets (`[` and `]`) at the start of the logged message is an _automatic prefix_ showing the logâ€™s time in the chartâ€™s time zone. For more information, refer to the Pine Logs section of the Debugging page.


Notice
In Pine v6, programmers can use _line wrapping_ to define a single literal string across multiple code lines. Each new wrapped line within the string can be indented by _any_ number of spaces, including multiples of four. Regardless of the indentation length, each wrapped line adds exactly **one** space to the beginning of its character sequence.
  

However, this behavior is _deprecated_ ; future versions of Pine Script might not support it. Instead of wrapping a single literal string across multiple lines, programmers can split that string into smaller strings, then concatenate them in a line-wrapped expression using the + operator. See the Line wrapping section of our Style guide for an example.

## Escape sequences
The backslash character (`\`), also known as the Reverse Solidus in Unicode (U+005C), is an _escape character_ in Pine strings. This character forms an _escape sequence_ when it precedes another character, signaling that the following character has a potentially _different_ meaning than usual.
Characters with a special meaning in â€œstringâ€ value definitions, such as quotation marks and backslashes, become _literal_ characters when prefixed by a backslash (e.g., `\\` includes a single `\` in the character sequence).
This simple script declares a variable with an assigned literal â€œstringâ€ value enclosed in apostrophes (`'`) and displays the valueâ€™s contents in the Pine Logs pane. It uses the `\` character to escape an extra apostrophe and another backslash, making them literal characters in the displayed text:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("EscapingÂ specialÂ charactersÂ demo")  
  
//@variableÂ AÂ stringÂ containingÂ escapedÂ `\`Â andÂ `'`Â characters.Â   
stringÂ displayTextÂ =Â 'TheÂ backslashÂ (\\)Â canÂ changeÂ anotherÂ character\'sÂ meaningÂ inÂ PineÂ strings.'  
  
ifÂ barstate.isfirst  
Â Â Â Â log.info(displayText)  
`
Note that:
  * This example must prefix the `'` character with a backslash in the stringâ€™s sequence because it also uses that character to mark its start and end boundaries. Without the backslash, it causes a _compilation error_. The script does not need to escape the apostrophe if we change the literal stringâ€™s enclosing characters to quotation marks (`"`).


The ASCII characters `n` and `t` usually have a literal meaning in Pine strings. However, when prefixed by the backslash character, they form escape sequences representing _control characters_. The `\n` sequence represents the newline character (U+000A), a line terminator for multiline text. The `\t` sequence represents the horizontal tab character (U+0009), which is helpful for indentation.
The script below creates a â€œstringâ€ value with multiline text on a single line of code, which it displays in a label on the last historical bar. The defined value contains several `\n` and `\t` escape sequences to include line terminators and tab spaces in the displayed text:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("ControlÂ charactersÂ demo",Â overlayÂ =Â true)  
  
ifÂ barstate.islastconfirmedhistory  
Â Â Â Â //@variableÂ AÂ stringÂ containingÂ `\n`Â andÂ `\t`Â escapeÂ sequences.Â RendersÂ asÂ multilineÂ textÂ withÂ indentation.Â   
Â Â Â Â stringÂ displayTextÂ =Â "\This\n\tis\n\t\tmultiline\n\t\t\ttext\n\t\t\t\twith\n\t\t\t\t\ttabÂ spaces."  
Â Â Â Â //Â DrawÂ aÂ labelÂ showingÂ theÂ `displayText`Â atÂ theÂ bar'sÂ `high`.  
Â Â Â Â label.new(bar_index,Â high,Â displayText,Â styleÂ =Â label.style_label_left,Â sizeÂ =Â 24,Â textalignÂ =Â text.align_left)  
`
Note that:
  * The â€œstringâ€ value also includes `\` before the `T` character. However, that character still appears _literally_ in the displayed text. If a backslash applied to a character does not form a supported escape sequence, the characterâ€™s meaning _does not change_.

## Concatenation
The + and += operators signify _concatenation_ when the operands are strings. A concatenation operation appends the second operandâ€™s character sequence to the first operandâ€™s sequence to form a new, _combined_ â€œstringâ€ value.
For example, this script declares a `concatString` variable that holds the result of a concatenation operation. After declaring the variable, it uses the += operator to concatenate additional strings and reassign the variableâ€™s value. Then, the script calls log.info() to show the result in the Pine Logs pane:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("ConcatenationÂ demo",Â overlayÂ =Â true)  
  
ifÂ barstate.isfirst  
Â Â Â Â //Â DeclareÂ twoÂ variablesÂ thatÂ holdÂ concatenatedÂ literalÂ strings.  
Â Â Â Â stringÂ value1Â =Â "\n\nThisÂ 'string'Â isÂ "Â +Â "theÂ resultÂ "  
Â Â Â Â stringÂ value2Â =Â "ofÂ multipleÂ "Â +Â "concatenationÂ operations."  
  
Â Â Â Â //@variableÂ AÂ stringÂ producedÂ byÂ concatenatingÂ `value1`,Â `value2`,Â andÂ fourÂ literalÂ strings.Â   
Â Â Â Â stringÂ displayTextÂ =Â value1Â +Â value2Â +Â "\n"  
  
Â Â Â Â //Â UseÂ twoÂ concatenationÂ assignmentsÂ toÂ createÂ newÂ stringsÂ fromÂ `displayText`Â andÂ literalÂ strings.Â   
Â Â Â Â displayTextÂ +=Â "\nEachÂ operationÂ createsÂ aÂ newÂ 'string'Â inÂ memoryÂ that"  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â +Â "Â combinesÂ theÂ characterÂ sequencesÂ ofÂ theÂ operands"  
Â Â Â Â displayTextÂ +=Â "Â withoutÂ modifyingÂ theÂ originalÂ values."  
Â Â Â Â //Â LogÂ theÂ `displayText`Â inÂ theÂ PineÂ LogsÂ pane.  
Â Â Â Â log.info(displayText)  
`
Note that:
  * Strings are immutable and cannot change. Therefore, every concatenation operation creates a _new_ â€œstringâ€ value in memory. The operation does **not** modify either â€œstringâ€ operand directly.
  * Another, more advanced way to combine strings is to collect them inside an array and use the array.join() function. For more information, see the Joining section of the Arrays page.
  * In many cases, programmers can efficiently create _formatted strings_ with str.format() instead of combining individual strings with concatenation or joining. See the Formatting strings section to learn more.

## String conversion and formatting
Programmers can use strings to represent data of virtually any type as human-readable character sequences. Converting data to strings allows scripts to perform many helpful tasks, including:
  * Displaying dynamic prices and calculations as text inside labels, tables, or boxes.
  * Creating alert messages containing realtime market and indicator information.
  * Logging debug messages containing calculated script information in the Pine Logs pane.
  * Performing custom calculations and logic, such as constructing symbol or timeframe strings for data requests.


### Converting values to strings
The simplest way to convert data to strings is to call the str.tostring() function. The function can represent values of several types as strings, based on predefined or custom formats. It has the following two signatures:
```

str.tostring(value) â†’ string


str.tostring(value, format) â†’ string

```

The functionâ€™s `value` parameter accepts any â€œintâ€, â€œfloatâ€, â€œboolâ€, or â€œstringâ€ value; the reference of an array or matrix containing values of these types; or a member of an enum type.
For example, this line of code creates a string representing the â€œfloatâ€ value `123.456`, with default formatting. The result is usable in â€œstringâ€ operations and any script outputs that display _dynamic_ text, such as labels and tables:
Pine ScriptÂ®
Copied
`//@variableÂ HoldsÂ theÂ "string"Â valueÂ `"123.456"`.  
stringÂ numStringÂ =Â str.tostring(123.456)  
`
The str.tostring() functionâ€™s `format` parameter determines the _numeric format_ for converted â€œintâ€ and â€œfloatâ€ values, arrays, and matrices. It can use one of the following `format.*` constants: format.mintick, format.percent, or format.volume. Alternatively, programmers can use strings containing `#` (number sign), `0` (zero), `.` (period), `,` (comma), and `%` (percent sign) tokens for customized _formatting patterns_ with specific decimal precision. The default numeric format is `"#.########"`, which rounds fractional digits to eight decimal places without trailing zeros.
The script below uses the str.tostring() function to convert numeric values, a â€œboolâ€ value, arrays, and a matrix into strings and displays the results in a table on the last bar. The str.tostring() calls that convert numeric values and collections contain different `format` arguments to demonstrate how various formatting patterns affect the results:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("StringÂ conversionÂ demo")  
  
//@variableÂ AÂ 2-row,Â 15-columnÂ tableÂ showingÂ "string"Â representationsÂ ofÂ numbers,Â "bool"Â values,Â andÂ collections.Â   
varÂ tableÂ displayTableÂ =Â table.new(position.middle_center,Â 2,Â 15,Â frame_colorÂ =Â chart.fg_color,Â frame_widthÂ =Â 1)  
  
//@functionÂ InitializesÂ aÂ rowÂ toÂ showÂ twoÂ specifiedÂ stringsÂ inÂ theÂ displayÂ table.  
makeRow(intÂ row,Â stringÂ str0,Â stringÂ str1)Â =>  
Â Â Â Â colorÂ bgColorÂ Â Â =Â rowÂ ==Â 0Â ?Â chart.fg_colorÂ :Â chart.bg_color  
Â Â Â Â colorÂ textColorÂ =Â rowÂ ==Â 0Â ?Â chart.bg_colorÂ :Â chart.fg_color  
Â Â Â Â displayTable.cell(0,Â row,Â str0,Â text_colorÂ =Â textColor,Â text_halignÂ =Â text.align_left,Â bgcolorÂ =Â bgColor)  
Â Â Â Â displayTable.cell(1,Â row,Â str1,Â text_colorÂ =Â textColor,Â text_halignÂ =Â text.align_left,Â bgcolorÂ =Â bgColor)  
  
//Â InitializeÂ theÂ headerÂ rowÂ forÂ theÂ `displayTable`Â onÂ theÂ firstÂ bar.Â   
ifÂ barstate.isfirst  
Â Â Â Â makeRow(0,Â "Variable",Â "'string'Â value")  
  
//Â ComputeÂ severalÂ "string"Â conversionsÂ andÂ populateÂ theÂ `displayTable`Â withÂ theÂ resultsÂ onÂ theÂ lastÂ bar.Â   
ifÂ barstate.islast  
Â Â Â Â //@variableÂ RepresentsÂ `ta.vwap`Â withÂ theÂ defaultÂ numericÂ formatÂ (`#.########`).  
Â Â Â Â stringÂ numberRepr1Â =Â str.tostring(ta.vwap)  
Â Â Â Â //@variableÂ RepresentsÂ `ta.vwap`Â roundedÂ toÂ theÂ minimumÂ tickÂ withoutÂ trailingÂ zeros.  
Â Â Â Â stringÂ numberRepr2Â =Â str.tostring(ta.vwap,Â format.mintick)  
Â Â Â Â //@variableÂ RepresentsÂ `ta.vwap`Â roundedÂ toÂ threeÂ fractionalÂ digitsÂ withoutÂ trailingÂ zeros.  
Â Â Â Â stringÂ numberRepr3Â =Â str.tostring(ta.vwap,Â "#.###")  
Â Â Â Â //@variableÂ RepresentsÂ `ta.vwap`Â roundedÂ toÂ fiveÂ fractionalÂ digitsÂ withÂ trailingÂ zeros.  
Â Â Â Â stringÂ numberRepr4Â =Â str.tostring(ta.vwap,Â "0.00000")  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `ta.vwap`Â asÂ anÂ integer.  
Â Â Â Â stringÂ numberRepr5Â =Â str.tostring(ta.vwap,Â "#")  
Â Â Â Â //@variableÂ RepresentsÂ `ta.vwap`Â asÂ anÂ integerÂ withÂ leadingÂ zeros.  
Â Â Â Â stringÂ numberRepr6Â =Â str.tostring(ta.vwap,Â "000000")  
Â Â Â Â //@variableÂ RepresentsÂ `ta.vwap`Â withÂ commasÂ forÂ eachÂ thirdÂ wholeÂ digitÂ fromÂ theÂ decimalÂ point.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ValuesÂ lessÂ thanÂ 1000000Â includeÂ leadingÂ zeros.Â TheÂ fractionalÂ partÂ includesÂ upÂ toÂ twoÂ digits.  
Â Â Â Â stringÂ numberRepr7Â =Â str.tostring(ta.vwap,Â "0000,000.##")  
Â Â Â Â //@variableÂ RepresentsÂ `100Â *Â ta.trÂ /Â close`Â roundedÂ toÂ twoÂ fractionalÂ digitsÂ withÂ `%`Â atÂ theÂ end.Â   
Â Â Â Â stringÂ numberRepr8Â =Â str.tostring(100Â *Â ta.trÂ /Â close,Â format.percent)  
Â Â Â Â //@variableÂ RepresentsÂ `ta.trÂ /Â close`Â asÂ aÂ percentageÂ roundedÂ toÂ fourÂ fractionalÂ digits.Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â WithÂ `%`Â atÂ theÂ endÂ ofÂ theÂ `format`,Â theÂ functionÂ multipliesÂ theÂ representedÂ numberÂ byÂ 100.Â   
Â Â Â Â stringÂ numberRepr9Â =Â str.tostring(ta.trÂ /Â close,Â "#.####%")  
Â Â Â Â //@variableÂ RepresentsÂ `volume`Â withÂ fixedÂ precisionÂ andÂ letterÂ charactersÂ forÂ largeÂ figures.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â `K`Â meansÂ "thousand",Â `M`Â meansÂ "million",Â `B`Â meansÂ "billion",Â andÂ `T`Â meansÂ "trillion".  
Â Â Â Â stringÂ numberRepr10Â =Â str.tostring(volume,Â format.volume)  
Â Â Â Â //@variableÂ RepresentsÂ aÂ "bool"Â value.Â IsÂ `"true"`Â whenÂ `ta.tr`Â exceedsÂ theÂ bar'sÂ range,Â `"false"`Â otherwise.Â   
Â Â Â Â stringÂ boolReprÂ =Â str.tostring(ta.trÂ >Â highÂ -Â low)  
Â   
Â Â Â Â //Â CreateÂ anÂ arrayÂ andÂ matrixÂ ofÂ priceÂ valuesÂ toÂ convertÂ intoÂ strings.Â   
Â Â Â Â array<float>Â Â pricesArrayÂ Â =Â array.from(open,Â close,Â low,Â high)  
Â Â Â Â matrix<float>Â pricesMatrixÂ =Â matrix.new<float>(),Â pricesMatrix.add_row(0,Â pricesArray),Â pricesMatrix.reshape(2,Â 2)  
  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `pricesArray`Â valuesÂ withÂ upÂ toÂ twoÂ decimalÂ placesÂ andÂ noÂ trailingÂ zerosÂ forÂ eachÂ element.Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ContainsÂ `[`Â andÂ `]`Â charactersÂ toÂ markÂ theÂ startÂ andÂ endÂ ofÂ theÂ array'sÂ contents.Â   
Â Â Â Â stringÂ numberArrayReprÂ =Â str.tostring(pricesArray,Â "#.##")  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `pricesMatrix`Â valuesÂ withÂ fourÂ decimalÂ placesÂ andÂ trailingÂ zerosÂ forÂ eachÂ element.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ContainsÂ `[`Â andÂ `]`Â charactersÂ toÂ markÂ theÂ startÂ andÂ endÂ ofÂ eachÂ row.Â   
Â Â Â Â stringÂ numberMatrixReprÂ =Â str.tostring(pricesMatrix,Â "#.0000")  
Â Â Â Â //@variableÂ RepresentsÂ aÂ "string"Â arrayÂ containingÂ theÂ symbol'sÂ typeÂ andÂ currency.  
Â Â Â Â stringÂ stringArrayReprÂ =Â str.tostring(array.from(syminfo.type,Â syminfo.currency))  
  
Â Â Â Â //Â PopulateÂ theÂ `displayTable`Â rowsÂ withÂ eachÂ ofÂ theÂ aboveÂ variableÂ namesÂ andÂ theirÂ assignedÂ "string"Â values.Â   
Â Â Â Â makeRow(1,Â Â "numberRepr1",Â Â Â Â Â Â numberRepr1)  
Â Â Â Â makeRow(2,Â Â "numberRepr2",Â Â Â Â Â Â numberRepr2)  
Â Â Â Â makeRow(3,Â Â "numberRepr3",Â Â Â Â Â Â numberRepr3)  
Â Â Â Â makeRow(4,Â Â "numberRepr4",Â Â Â Â Â Â numberRepr4)  
Â Â Â Â makeRow(5,Â Â "numberRepr5",Â Â Â Â Â Â numberRepr5)  
Â Â Â Â makeRow(6,Â Â "numberRepr6",Â Â Â Â Â Â numberRepr6)  
Â Â Â Â makeRow(7,Â Â "numberRepr7",Â Â Â Â Â Â numberRepr7)  
Â Â Â Â makeRow(8,Â Â "numberRepr8",Â Â Â Â Â Â numberRepr8)  
Â Â Â Â makeRow(9,Â Â "numberRepr9",Â Â Â Â Â Â numberRepr9)  
Â Â Â Â makeRow(10,Â "numberRepr10",Â Â Â Â Â numberRepr10)  
Â Â Â Â makeRow(11,Â "boolRepr",Â Â Â Â Â Â Â Â Â boolRepr)  
Â Â Â Â makeRow(12,Â "numberArrayRepr",Â Â numberArrayRepr)  
Â Â Â Â makeRow(13,Â "numberMatrixRepr",Â numberMatrixRepr)  
Â Â Â Â makeRow(14,Â "stringArrayRepr",Â Â stringArrayRepr)  
`
Note that:
  * The `#` and `0` tokens control the digits in the represented numbers in a similar way, but with different behaviors for leading and trailing _zeros_ , as shown above. The `0` token _always_ includes a digit at the specified decimal place, even for a leading or trailing zero, whereas the `#` token allows a leading or trailing digit only if it is _nonzero_.
  * The `format` argument requires a `#` or `0` token for each _fractional_ digit in a converted number. These tokens are optional for extra _whole_ digits, because str.tostring() includes the necessary digits automatically.
  * A single `,` token adds _repeated_ comma separation to whole digits. In the str.tostring() call with the format `"0000,000.##"`, the token specifies that the result includes a dividing comma for every set of _three digits_ to the left of the decimal point.
  * When the `%` token is at the _end_ of the formatting string, the representation multiplies numbers by 100 to express them as percentages, as shown by the example that uses `"#.####%"`.


TipScripts can convert a numeric â€œstringâ€ value back to a â€œfloatâ€ value with str.tonumber(). When converting strings to numbers with this function, the valueâ€™s character sequence can include only ASCII digits, a sign symbol at the beginning (`+` or `-`), and a single period for the decimal point (`.`). If the specified â€œstringâ€ value does not represent a number with this format, the function returns na. For example, the function can convert `"1234.50"` to a â€œfloatâ€ value, but it cannot convert strings such as `"$1,234.50"`.
### Formatting strings
The str.format() function can combine multiple â€œintâ€, â€œfloatâ€, â€œboolâ€, â€œstringâ€, or array arguments into one output string in a specified format. Using this function is a simpler alternative to creating multiple separate strings and combining them with repeated concatenation operations. Below is the functionâ€™s signature:
```

str.format(formatString, arg0, arg1, ...) â†’ string

```

NoteThe second overloads of all `log.*()` functions have the _same_ parameter signature and formatting behaviors as str.format(). However, they generate _logs_ with formatted text instead of returning usable strings. See the Pine Logs section of the Debugging page to learn more about these functions.
The `formatString` parameter accepts a â€œstringâ€ value that defines the _format_ of the returned string, where the _placeholders_ in curly brackets (`{}`) refer to the function callâ€™s _additional arguments_. The placeholder `"{0}"` represents the first additional argument `arg0`, `"{1}"` represents `arg1`, and so on. The function _replaces_ each placeholder in the `formatString` with a string representation of the corresponding argument. For instance, the call `str.format("The timeframe multiplier is {0}", timeframe.multiplier)` on a 1D chart returns `"The timeframe multiplier is 1"`.
The following example constructs a formatted string containing various bar information, then displays the result in a label at the barâ€™s high. The str.format() callâ€™s `formatString` argument includes placeholders for 10 values, where each placeholderâ€™s _number_ corresponds to one of the additional â€œstringâ€, â€œboolâ€, â€œintâ€, or â€œfloatâ€ arguments:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("FormattingÂ stringsÂ demo",Â overlayÂ =Â true)  
  
//@variableÂ CountsÂ scriptÂ executionsÂ inÂ aÂ bar.Â DoesÂ notÂ rollÂ backÂ becauseÂ itÂ isÂ declaredÂ withÂ `varip`.Â   
varipÂ intÂ exCountÂ =Â 0  
exCountÂ +=Â 1  
  
//@variableÂ IsÂ `true`Â whenÂ theÂ `close`Â exceedsÂ theÂ currentÂ `open`Â andÂ theÂ previousÂ `close`;Â `false`Â otherwise.Â   
boolÂ risingÂ =Â closeÂ >Â math.max(nz(close[1]),Â open)  
//@variableÂ IsÂ `"realtime"`Â forÂ allÂ newÂ barsÂ afterÂ theÂ script'sÂ historicalÂ executions;Â `"historical"`Â otherwise.Â   
stringÂ barStateÂ =Â barstate.isrealtimeÂ ?Â "realtime"Â :Â "historical"  
  
//@variableÂ AÂ formattingÂ stringÂ containingÂ placeholdersÂ forÂ 10Â values.Â   
stringÂ formatStringÂ =Â "Bar:Â {1}Â ({9}){0}{0}Executions:Â {2}{0}O:Â {3}{0}H:Â {4}{0}L:Â {5}{0}C:Â {6}{0}V:Â {7}{0}Rising:Â {8}"  
  
//@variableÂ AÂ multilineÂ stringÂ containingÂ formattedÂ informationÂ forÂ theÂ currentÂ bar.Â   
stringÂ formattedStringÂ =Â str.format(  
Â Â Â Â Â formatString,Â "\n\t",Â bar_index,Â exCountÂ -Â nz(exCount[1]),Â open,Â high,Â low,Â close,Â volume,Â rising,Â barState  
Â )  
  
//Â DrawÂ aÂ labelÂ displayingÂ theÂ `formattedString`Â atÂ theÂ bar'sÂ `high`.Â   
label.new(bar_index,Â high,Â formattedString,Â sizeÂ =Â 18,Â textalignÂ =Â text.align_left)  
`
Note that:
  * The `formatString` argument can use placeholders in _any order_ and can repeat specific placeholders _more than once_. The format in this example uses `{0}` multiple times to insert the first argument (`"\n\t"`) to create multiline text with indentation.
  * If a placeholder refers to a nonexistent argument, the formatted result treats that placeholder as a _literal_ character sequence. For instance, a placeholder such as `{20}` in the `formatString` argument above includes those characters literally in the formatted result, because the str.format() call _does not_ contain 21 additional arguments.
  * _Non-quoted_ left curly brackets (`{`) must have corresponding right curly brackets (`}`) inside formatting strings. If a `formatString` contains unbalanced curly brackets, it causes a _runtime error_.


Itâ€™s important to note that the apostrophe (`'`) acts as a _quote character_ inside formatting strings. When a formatting string contains a character sequence between two apostrophes, the formatted result includes that sequence directly, without treating the characters as placeholders or formatting tokens. This behavior applies even if the formatting string prefixes apostrophes with the backslash character (`\`). The enclosing apostrophes for a non-empty quoted sequence are **not** part of the formatted string. To include literal apostrophes in a str.format() callâ€™s result, pass a â€œstringâ€ value containing the character as an _extra argument_ , then use that argumentâ€™s _placeholder_ in the specified `formatString`. Alternatively, use pairs of apostrophes with no characters between them directly in the `formatString` (e.g., `''` adds a single `'` character in the result).
The example below demonstrates how using apostrophes directly in formatting strings differs from inserting them via placeholders. The script uses the `'` character directly in the str.format() callâ€™s `formatString` to define a _quoted sequence_ , and it uses the `{1}` placeholder to insert the character from an extra argument without creating a quoted sequence. The script displays the resulting `formattedString` value in a single-cell table on the first bar:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("QuotesÂ inÂ formattingÂ stringsÂ demo")  
  
ifÂ barstate.isfirst  
Â Â Â Â //@variableÂ AÂ concatenatedÂ formattingÂ stringÂ thatÂ containsÂ apostrophesÂ andÂ placeholders.  
Â Â Â Â stringÂ formatStringÂ =Â   
Â Â Â Â Â Â Â Â Â "ApostrophesÂ inÂ formattingÂ stringsÂ signifyÂ quotedÂ characterÂ sequences,Â whichÂ doÂ notÂ haveÂ specialÂ meaning."  
Â Â Â Â Â Â Â Â Â +Â "\n\nQuotingÂ aÂ placeholderÂ includesÂ itsÂ charactersÂ literally:Â '{0}'"  
Â Â Â Â Â Â Â Â Â +Â "\n\nInsertingÂ theÂ apostropheÂ characterÂ fromÂ argumentsÂ doesÂ *not*Â createÂ quotedÂ sequences:Â {1}{0}{1}"Â   
Â Â Â Â //@variableÂ AÂ formattedÂ stringÂ showingÂ howÂ usingÂ `'`Â directlyÂ differsÂ fromÂ insertionÂ viaÂ arguments.Â   
Â Â Â Â stringÂ formattedStringÂ =Â str.format(formatString,Â ticker.standard(),Â "'")  
  
Â Â Â Â //@variableÂ AÂ single-cellÂ tableÂ toÂ displayÂ theÂ `formattedString`.  
Â Â Â Â tableÂ displayÂ =Â table.new(position.middle_center,Â 1,Â 1,Â color.purple)  
Â Â Â Â //Â InitializeÂ theÂ cellÂ withÂ white,Â left-alignedÂ text.Â   
Â Â Â Â display.cell(0,Â 0,Â formattedString,Â text_colorÂ =Â color.white,Â text_halignÂ =Â text.align_left,Â text_sizeÂ =Â 20)  
`
When a str.format() call contains â€œintâ€ or â€œfloatâ€ arguments, the placeholders for those arguments in the `formatString` can include the `number` _modifier_ followed by a _formatting pattern_ for customized numeric formats (e.g., `"{0,number,#.000}"`).
The possible numeric formatting patterns are similar to those for the `format` parameter of str.tostring(). They can contain `#`, `0`, and `.` tokens to specify decimal precision; use the `,` token for comma separation; and include `%` at the end for percentage conversion. Alternatively, a placeholder can use one of the following _keywords_ that specify _predefined_ formatting patterns: `integer`, `currency`, or `percent`.
The script below demonstrates how different numeric formats in a `formatString` placeholder affect the formatted representation of a â€œfloatâ€ value. On the last bar, the script generates a pseudorandom value between 0 and 10000 with math.random(), uses several str.format() calls to format the value in different ways, and displays the results in a table:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("NumericÂ formattingÂ demo")  
  
//@variableÂ AÂ two-row,Â eight-columnÂ tableÂ showingÂ aÂ pseudorandomÂ numberÂ formattedÂ withÂ differentÂ formatÂ patterns.Â   
varÂ tableÂ displayÂ =Â table.new(position.middle_center,Â 2,Â 8,Â frame_colorÂ =Â chart.fg_color,Â frame_widthÂ =Â 1)  
  
//@variableÂ InitializesÂ aÂ rowÂ toÂ showÂ twoÂ specifiedÂ stringsÂ inÂ theÂ `display`Â table.  
makeRow(intÂ row,Â stringÂ str0,Â stringÂ str1)Â =>  
Â Â Â Â colorÂ bgColorÂ Â Â =Â rowÂ ==Â 0Â ?Â chart.fg_colorÂ :Â chart.bg_color  
Â Â Â Â colorÂ textColorÂ =Â rowÂ ==Â 0Â ?Â chart.bg_colorÂ :Â chart.fg_color  
Â Â Â Â display.cell(0,Â row,Â str0,Â text_colorÂ =Â textColor,Â text_halignÂ =Â text.align_left,Â text_sizeÂ =Â 30,Â bgcolorÂ =Â bgColor)  
Â Â Â Â display.cell(1,Â row,Â str1,Â text_colorÂ =Â textColor,Â text_halignÂ =Â text.align_left,Â text_sizeÂ =Â 30,Â bgcolorÂ =Â bgColor)  
  
//Â InitializeÂ theÂ headerÂ rowÂ forÂ theÂ `display`Â tableÂ onÂ theÂ firstÂ bar.Â   
ifÂ barstate.isfirst  
Â Â Â Â makeRow(0,Â "FormatÂ pattern",Â "Result")  
  
ifÂ barstate.islast  
Â Â Â Â //@variableÂ AÂ pseudorandomÂ valueÂ betweenÂ 0Â andÂ 10000.Â   
Â Â Â Â floatÂ valueÂ =Â math.random(0,Â 10000)  
  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `value`Â usingÂ theÂ `str.format()`Â function'sÂ defaultÂ numericÂ formatÂ (`#,###.###`).  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ formatÂ usesÂ comma-separatedÂ setsÂ ofÂ threeÂ wholeÂ digits,Â andÂ allowsÂ upÂ toÂ threeÂ fractionalÂ digits.Â Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ defaultÂ differsÂ fromÂ theÂ defaultÂ forÂ `str.tostring()`Â (`#.########`).Â   
Â Â Â Â stringÂ defaultÂ =Â str.format("{0}",Â value)  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `value`Â usingÂ theÂ `integer`Â presetÂ (`#,###`).Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ formatÂ roundsÂ theÂ `value`Â toÂ theÂ nearestÂ wholeÂ andÂ addsÂ commaÂ separationÂ forÂ three-digitÂ sets.Â   
Â Â Â Â stringÂ integerPresetÂ =Â str.format("{0,number,integer}",Â value)  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `value`Â asÂ anÂ integerÂ withoutÂ comma-separatedÂ digitsÂ (`#`).Â   
Â Â Â Â stringÂ integerNoCommaÂ =Â str.format("{0,number,#}",Â value)  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `value`Â usingÂ theÂ `currency`Â presetÂ (`'$'#,###.00`).Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ formatÂ prefixesÂ theÂ resultÂ withÂ theÂ `$`Â symbol,Â addsÂ commaÂ separationÂ forÂ setsÂ ofÂ threeÂ wholeÂ   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â digits,Â andÂ includesÂ twoÂ fractionalÂ digits.Â   
Â Â Â Â stringÂ currencyPresetÂ =Â str.format("{0,number,currency}",Â value)  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `value`Â inÂ dollarsÂ withÂ comma-separatedÂ wholeÂ digitsÂ andÂ fourÂ fractionalÂ digitsÂ (`'$',###.0000`).Â   
Â Â Â Â stringÂ currencyCustomÂ =Â str.format("{0,number,'$',###.0000}",Â value)  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `value`Â usingÂ theÂ `percent`Â presetÂ (`#,###%`).  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ formatÂ multipliesÂ theÂ `value`Â byÂ 100,Â roundsÂ theÂ resultÂ toÂ theÂ nearestÂ wholeÂ number,Â addsÂ commaÂ   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â separationÂ forÂ three-digitÂ sets,Â andÂ includesÂ theÂ `%`Â symbolÂ atÂ theÂ end.Â   
Â Â Â Â stringÂ percentPresetÂ =Â str.format("{0,number,percent}",Â value)  
Â Â Â Â //@variableÂ RepresentsÂ theÂ `value`Â asÂ aÂ percentageÂ withÂ comma-separatedÂ wholeÂ digitsÂ andÂ upÂ toÂ threeÂ fractionalÂ digits.Â   
Â Â Â Â stringÂ percentCustomÂ =Â str.format("{0,number,#,###.###%}",Â value)  
  
Â Â Â Â //Â InitializeÂ rowsÂ showingÂ eachÂ numericÂ formatÂ andÂ theÂ resultingÂ representationÂ ofÂ theÂ `value`.Â   
Â Â Â Â makeRow(1,Â "DefaultÂ (#,###.###)",Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â default)  
Â Â Â Â makeRow(2,Â "integerÂ (#,###)",Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â integerPreset)  
Â Â Â Â makeRow(3,Â "integerÂ withoutÂ commasÂ (#)",Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â integerNoComma)  
Â Â Â Â makeRow(4,Â "currencyÂ ('$'#,###.00)",Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â currencyPreset)  
Â Â Â Â makeRow(5,Â "currencyÂ withÂ 4Â fractionalÂ digitsÂ ('$',###.0000)",Â Â Â Â currencyCustom)  
Â Â Â Â makeRow(6,Â "percentÂ (#,###%)",Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â percentPreset)  
Â Â Â Â makeRow(7,Â "percentÂ withÂ upÂ toÂ 3Â fractionalÂ digitsÂ (#,###.###%)",Â percentCustom)  
`
Note that:
  * In contrast to str.tostring(), the str.format() function does not directly support the preset formats defined by the `format.*` constants (format.mintick, format.percent, and format.volume). To use those formats on numeric values in a formatted string, convert the values with str.tostring() first, then use the resulting strings in the str.format() call.


The str.format() functionâ€™s `formatString` also supports placeholders with the `date` or `time` modifier, which can format an â€œintâ€ UNIX timestamp into a _UTC_ date or time. For example, this line of code creates a string representing the current barâ€™s opening timestamp as a date and time in the ISO 8601 standard format:
Pine ScriptÂ®
Copied
`stringÂ formattedTimeÂ =Â str.format("{0,date,yyyy-MM-dd}T{0,time,HH:mm:ssZ}",Â time)  
`
However, str.format() **cannot** express dates and times in other time zones. It uses _UTC+0_ exclusively. The specialized str.format_time() function is more optimal for constructing date-time strings, because it can express dates and times in _any time zone_. See the Formatting dates and times section of the Time page to learn more about this function and the available formatting tokens.
### Custom representations
All built-in functions that create â€œstringâ€ values to represent data support a limited subset of built-in types. They _do not_ support â€œcolorâ€ values or objects of most _reference types_ (e.g., labels). Programmers can, however, use custom logic and formatting to create â€œstringâ€ representations of data that the str.tostring() or str.format() functions cannot express as strings directly.
For example, this script demonstrates two ways to represent a â€œcolorâ€ value as a string based on its red, green, blue, and transparency components. The first method formats the color components directly. The second calculates and formats each componentâ€™s _hexadecimal_ form. The script displays the results of both custom formats in a label on the last historical bar.
After creating the label object, the script also uses log.info() to create formatted text containing the labelâ€™s `x`, `y`, and `text` _properties_ and display the result in the Pine Logs pane:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("CustomÂ representationsÂ demo",Â overlayÂ =Â true)  
  
//@variableÂ TheÂ "color"Â valueÂ toÂ colorÂ theÂ labelÂ andÂ convertÂ toÂ aÂ string.Â   
colorÂ colorInputÂ =Â input.color(#00897b)  
  
//@functionÂ ConstructsÂ aÂ formattedÂ stringÂ containingÂ theÂ color'sÂ R,Â G,Â B,Â andÂ TÂ components.Â   
rgbtString(colorÂ value)Â =>  
Â Â Â Â str.format("colorÂ (R:Â {0},Â G:Â {1},Â B:Â {2},Â T:Â {3})",Â color.r(value),Â color.g(value),Â color.b(value),Â color.t(value))  
  
//@variableÂ ConstructsÂ aÂ stringÂ containingÂ theÂ color'sÂ hexadecimalÂ RGBAÂ representation.Â   
hexString(colorÂ value)Â =>  
Â Â Â Â //@variableÂ AnÂ arrayÂ ofÂ hexadecimalÂ charactersÂ formedÂ byÂ splittingÂ aÂ string.Â   
Â Â Â Â varÂ array<string>Â charsÂ =Â str.split("0123456789abcdef",Â "")  
Â Â Â Â //Â GetÂ theÂ R,Â G,Â andÂ BÂ channelÂ valuesÂ fromÂ theÂ `value`.Â   
Â Â Â Â intÂ rÂ =Â int(color.r(value))  
Â Â Â Â intÂ gÂ =Â int(color.g(value))  
Â Â Â Â intÂ bÂ =Â int(color.b(value))  
Â Â Â Â //@variableÂ TheÂ AÂ (alpha)Â channelÂ valueÂ (oppositeÂ ofÂ transparency),Â scaledÂ toÂ theÂ rangeÂ [0,Â 255].Â   
Â Â Â Â intÂ aÂ =Â int((100Â -Â color.t(value))Â *Â 255Â /Â 100)  
Â Â Â Â //@variableÂ AÂ formattedÂ stringÂ combiningÂ hexÂ codesÂ forÂ theÂ R,Â G,Â B,Â andÂ AÂ channels.Â   
Â Â Â Â stringÂ resultÂ =Â str.format(  
Â Â Â Â Â Â Â Â Â "#{0}{1}{2}{3}{4}{5}{6}{7}",Â   
Â Â Â Â Â Â Â Â Â chars.get(int(rÂ /Â 16)),Â chars.get(rÂ %Â 16),  
Â Â Â Â Â Â Â Â Â chars.get(int(gÂ /Â 16)),Â chars.get(gÂ %Â 16),  
Â Â Â Â Â Â Â Â Â chars.get(int(bÂ /Â 16)),Â chars.get(bÂ %Â 16),  
Â Â Â Â Â Â Â Â Â chars.get(int(aÂ /Â 16)),Â chars.get(aÂ %Â 16)  
Â Â Â Â Â )  
  
ifÂ barstate.islastconfirmedhistory  
Â Â Â Â //@variableÂ AÂ formattedÂ stringÂ containingÂ theÂ resultsÂ ofÂ `rgbtString()`Â andÂ `hexString()`.  
Â Â Â Â stringÂ labelTextÂ =Â str.format("{0}\n{1}",Â rgbtString(colorInput),Â hexString(colorInput))  
Â Â Â Â //@variableÂ AÂ labelÂ displayingÂ theÂ `labelText`.Â TheÂ scriptÂ displaysÂ thisÂ object'sÂ propertiesÂ inÂ theÂ PineÂ LogsÂ pane.Â   
Â Â Â Â labelÂ displayLabelÂ =Â label.new(  
Â Â Â Â Â Â Â Â Â bar_index,Â high,Â labelText,Â colorÂ =Â colorInput,Â textcolorÂ =Â color.white,Â sizeÂ =Â 36  
Â Â Â Â Â )  
Â Â Â Â //Â LogÂ aÂ customÂ representationÂ ofÂ theÂ `displayLabel`Â inÂ theÂ PineÂ LogsÂ pane.  
Â Â Â Â log.info(  
Â Â Â Â Â Â Â Â Â "\nlabelÂ object\nx:Â {0,number,#}\ny:Â {1,number,#.#####}\ntext:Â {2}",Â   
Â Â Â Â Â Â Â Â Â displayLabel.get_x(),Â displayLabel.get_y(),Â displayLabel.get_text()  
Â Â Â Â Â )  
`
Note that:
  * Not all special types have retrievable properties. For instance, scripts cannot retrieve information from polylines or tables. To create strings for these types, track the data used in their creation with separate variables, then format the values of those variables into strings.
  * For an example of creating strings from the field values of user-defined types, see the Debugging objects of UDTs section of the Debugging page.

## Modifying strings
Several `str.*()` functions provide simplified ways to modify the character sequence from a â€œstringâ€ value, including str.replace(), str.replace_all(), str.upper(), str.lower(), str.trim(), and str.repeat().
Programmers can use these functions to create copies of strings with replaced character sequences, modified letter cases, trimmed whitespaces, or repeated character patterns.
### Replacing substrings
The str.replace() function searches a specified `source` string for the nth _non-overlapping_ occurrence of a given substring, then returns a copy of the original string containing a specified replacement at that substringâ€™s position.
The str.replace_all() function searches the `source` for _every_ non-overlapping occurrence of the substring and replaces each one in its returned value.
Below are the functionsâ€™ signatures:
```

str.replace(source, target, replacement, occurrence) â†’ string


str.replace_all(source, target, replacement) â†’ string

```

Where:
  * `source` is the â€œstringâ€ value containing the substrings to replace with a specified `replacement`.
  * `target` is the substring replaced by the `replacement` in the returned copy. If the `source` value does not contain the substring, the function returns a copy of the value without modification.
  * `replacement` is the substring inserted in place of the required `target` occurrences in the result.
  * The `occurrence` parameter for str.replace() specifies which non-overlapping occurrence of the `target` is swapped for the `replacement` in the result. The default value is 0, meaning the function replaces the _first_ occurrence of the `target`. If the specified occurrence does not exist in the `source` value, the function returns a copy of the value without modification.


The following script demonstrates the effects of str.replace() and str.replace_all() calls on a string containing the sequence `Hello world!`. Additionally, it calls these functions to define the `formatString` value for a str.format() call, which formats all the replacement results into a single â€œstringâ€ value. The script displays the formatted text inside a label anchored to the latest barâ€™s opening time:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("ReplacingÂ substringsÂ demo")  
  
ifÂ barstate.isfirst  
Â Â Â Â //@variableÂ AÂ stringÂ containingÂ theÂ sequenceÂ `HelloÂ world!`.  
Â Â Â Â stringÂ originalStringÂ =Â "HelloÂ world!"  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `originalString`Â withÂ `!`Â replacedÂ byÂ `!!!`.  
Â Â Â Â stringÂ changePunctuationÂ =Â str.replace(originalString,Â "!",Â "!!!")  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `originalString`Â withÂ theÂ secondÂ `o`Â replacedÂ byÂ `0`.  
Â Â Â Â stringÂ changeLetterÂ =Â str.replace(originalString,Â "o",Â "0",Â 1)  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `originalString`Â withÂ allÂ `l`Â charactersÂ replacedÂ byÂ 1.  
Â Â Â Â stringÂ changeLettersÂ =Â str.replace_all(originalString,Â "l",Â "1")  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `originalString`Â withÂ allÂ zero-widthÂ boundariesÂ replacedÂ byÂ `\n-`.Â   
Â Â Â Â stringÂ insertNewlinesÂ =Â str.replace_all(originalString,Â "",Â "\n")  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `originalString`Â withoutÂ changes,Â asÂ `H`Â doesÂ notÂ occurÂ twoÂ times.Â   
Â Â Â Â stringÂ unchangedÂ =Â str.replace(originalString,Â "HÂ ",Â "_",Â 1)  
  
Â Â Â Â //@variableÂ AÂ formattingÂ stringÂ withÂ theÂ followingÂ initialÂ structure:Â `{0}\n{1}\n{2}\n{3}\n{4}\n{5}`.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â TheÂ scriptÂ createsÂ theÂ stringÂ byÂ replacingÂ zero-widthÂ boundariesÂ inÂ theÂ sequenceÂ `012345`Â withÂ   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â `}\n{`Â usingÂ `str.replace_all()`,Â thenÂ removingÂ theÂ extraÂ `}\n`Â andÂ `\n{`Â fromÂ theÂ startÂ andÂ endÂ ofÂ theÂ   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â call'sÂ resultÂ withÂ twoÂ additionalÂ `str.replace()`Â calls.Â Â   
Â Â Â Â stringÂ formatStringÂ =Â str.replace(str.replace(str.replace_all("012345",Â "",Â "}\n{"),Â "}\n",Â ""),Â "\n{",Â "",Â 5)  
  
Â Â Â Â //Â CreateÂ aÂ copyÂ ofÂ theÂ `formatString`Â withÂ theÂ firstÂ `}`Â replacedÂ byÂ `}\n-----------------------`,Â thenÂ reassignÂ   
Â Â Â Â //Â theÂ variableÂ toÂ useÂ thatÂ copy.Â   
Â Â Â Â formatStringÂ :=Â str.replace(formatString,Â "}",Â "}\n-----------------------")  
  
Â Â Â Â //@variableÂ AÂ formattedÂ stringÂ containingÂ theÂ originalÂ andÂ modifiedÂ "HelloÂ world!"Â strings.Â   
Â Â Â Â stringÂ displayTextÂ =Â str.format(  
Â Â Â Â Â Â Â Â Â formatString,Â originalString,Â changePunctuation,Â changeLetter,Â changeLetters,Â insertNewlines,Â unchangedÂ Â Â Â Â   
Â Â Â Â Â )  
  
Â Â Â Â //Â DrawÂ aÂ labelÂ anchoredÂ toÂ theÂ latestÂ bar'sÂ openingÂ timeÂ toÂ showÂ theÂ `displayText`.Â   
Â Â Â Â label.new(  
Â Â Â Â Â Â Â Â Â math.max(last_bar_time,Â chart.right_visible_bar_time),Â 0,Â displayText,Â xloc.bar_time,Â   
Â Â Â Â Â Â Â Â Â styleÂ =Â label.style_label_center,Â sizeÂ =Â 20  
Â Â Â Â Â )  
`
Note that:
  * Each `str.replace*()` call creates an independent, modified copy of the specified `source` value. Because each modification of the `originalString` is assigned to a separate variable, each value _does not_ contain changes from previous `str.replace*()` calls.
  * The `str.replace*()` functions can replace zero-width _boundaries_ when the `target` is an empty string, as shown by the `formatString` declaration. The str.replace_all() call inserts `}\n{` around every character in the literal string `"012345"`.


TipWhen using str.replace(), knowing the precise number of substrings within the `source` value helps ensure correct results. A simple way to count substrings is to remove them with str.replace_all(), then measure the difference in length relative to the length of the removed substring. See the Counting characters and substrings section to learn more.
### Changing case
The str.upper() and str.lower() functions create a copy of a `source` string with all ASCII letter characters converted to _uppercase_ or _lowercase_ variants, providing a convenient alternative to replacing specific characters with several `str.replace*()` calls. The str.upper() function replaces all lowercase characters with uppercase characters, and str.lower() does the opposite. These are the functionsâ€™ signatures:
```

str.upper(source) â†’ string


str.lower(source) â†’ string

```

This simple example demonstrates how these functions affect strings with _standard_ letter characters. The script declares an `originalString` variable to hold a literal string, uses str.upper() on that variable to create a copied string with all letters converted to uppercase, then calls str.lower() to make a copy with only lowercase characters. It logs all three strings in the Pine Logs pane on the first bar:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("ChangingÂ caseÂ demo",Â overlayÂ =Â true)  
  
ifÂ barstate.isfirst  
Â Â Â Â //@variableÂ AÂ literalÂ stringÂ containingÂ theÂ sequenceÂ `HelloÂ World!`  
Â Â Â Â stringÂ originalStringÂ =Â "HelloÂ World!"  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `originalString`Â withÂ allÂ lowercaseÂ ASCIIÂ charactersÂ changedÂ toÂ uppercaseÂ characters.  
Â Â Â Â stringÂ uppercaseStringÂ =Â str.upper(originalString)  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `uppercaseString`Â withÂ allÂ uppercaseÂ ASCIIÂ charactersÂ changedÂ toÂ lowercaseÂ characters.Â   
Â Â Â Â stringÂ lowercaseStringÂ =Â str.lower(uppercaseString)  
  
Â Â Â Â //Â LogÂ aÂ formattedÂ messageÂ containingÂ allÂ threeÂ values.  
Â Â Â Â log.info("\n\nOriginal:Â {0}\nUppercase:Â {1}\nLowercase:Â {2}",Â originalString,Â uppercaseString,Â lowercaseString)  
`
Note that these functions can only change the cases of _ASCII_ letter characters. They cannot convert other Unicode letters outside the ASCII range. For example, this script attempts to create uppercase and lowercase versions of a â€œstringâ€ value containing â€œMathematical Sans-Serifâ€ Unicode characters using str.upper() and str.lower(). As shown below, both function calls return _identical_ copies of the value:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("Non-ASCIIÂ caseÂ demo",Â overlayÂ =Â true)  
  
ifÂ barstate.isfirst  
Â Â Â Â //@variableÂ AÂ literalÂ stringÂ thatÂ usesÂ UnicodeÂ charactersÂ inÂ theÂ "MathematicalÂ Sans-Serif"Â family.Â   
Â Â Â Â stringÂ originalStringÂ =Â "ğ–³ğ—ğ—‚ğ—ŒÂ ğ—Œğ—ğ—‹ğ—‚ğ—‡ğ—€Â ğ—‚ğ—ŒÂ ğ—ğ—‡ğ–ºğ–¿ğ–¿ğ–¾ğ–¼ğ—ğ–¾ğ–½Â ğ–»ğ—’Â ğ—ğ—ğ–¾Â ğ–¼ğ–ºğ—Œğ–¾-ğ—Œğ—ğ–ºğ—‰ğ—‰ğ—‚ğ—‡ğ—€Â ğ–¿ğ—ğ—‡ğ–¼ğ—ğ—‚ğ—ˆğ—‡ğ—Œ!"  
  
Â Â Â Â //Â CallÂ `str.upper()`Â andÂ `str.lower()`Â toÂ changeÂ theÂ caseÂ ofÂ letters.Â   
Â Â Â Â //Â AlthoughÂ theÂ charactersÂ inÂ theÂ `originalString`Â haveÂ theÂ "Letter"Â property,Â theyÂ areÂ notÂ partÂ ofÂ theÂ standardÂ   
Â Â Â Â //Â ASCIIÂ set.Â Consequently,Â theseÂ callsÂ returnÂ unmodifiedÂ strings.Â   
Â Â Â Â stringÂ uppercaseStringÂ =Â str.upper(originalString)  
Â Â Â Â stringÂ lowercaseStringÂ =Â str.lower(uppercaseString)  
  
Â Â Â Â //Â LogÂ aÂ formattedÂ messageÂ containingÂ allÂ threeÂ values.  
Â Â Â Â log.info("\n\nOriginal:Â {0}\nUppercase:Â {1}\nLowercase:Â {2}",Â originalString,Â uppercaseString,Â lowercaseString)  
`
### Trimming whitespaces
The str.trim() function copies a `source` string and removes leading and trailing whitespace characters, including the standard space (`\n`), and tab space (`\t`). Below is the functionâ€™s signature:
```

str.trim(source) â†’ string

```

This simple example demonstrates the str.trim() functionâ€™s behavior. The script creates a literal string containing different types of whitespaces at the start and end of the character sequence. Then, it uses str.trim() to create a new â€œstringâ€ value with those characters removed. The script formats both values into a single string, then displays the result in a label on the last historical bar:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("TrimmingÂ whitespacesÂ demo")  
  
ifÂ barstate.islastconfirmedhistory  
Â Â Â Â //@variableÂ AÂ literalÂ stringÂ containingÂ space,Â newline,Â andÂ tabÂ characters.Â   
Â Â Â Â stringÂ originalStringÂ =Â "\n\n\t\tABCÂ DEF\tÂ Â \n\nÂ Â Â "  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `originalString`Â thatÂ containsÂ onlyÂ `ABCÂ DEF`Â withoutÂ theÂ otherÂ whitespaces.  
Â Â Â Â stringÂ trimmedStringÂ =Â str.trim(originalString)  
  
Â Â Â Â //@variableÂ AÂ formattedÂ stringÂ containingÂ theÂ `originalString`Â andÂ `trimmedString`Â values.  
Â Â Â Â stringÂ displayTextÂ =Â str.format("Original:Â \"{0}\"\n---\n\nTrimmed:Â \"{1}\"",Â originalString,Â trimmedString)  
  
Â Â Â Â //Â DrawÂ aÂ labelÂ toÂ showÂ theÂ `displayText`.  
Â Â Â Â label.new(bar_index,Â 0,Â displayText,Â styleÂ =Â label.style_label_center,Â sizeÂ =Â 30,Â textalignÂ =Â text.align_left)  
`
Note that:
  * The str.trim() function removes only the ASCII whitespaces to the left of the _first_ non-whitespace character and the right of the _last_ non-whitespace character. It does **not** remove whitespaces between other characters.
  * The formatting string in the str.format() call uses `\"` to include quotation marks around the `originalString` and `trimmedString` values in the displayed text. See the Escape sequences section above for more information.


The str.trim() function is particularly helpful when supplying calculated or input strings to built-in functions that process â€œstringâ€ arguments, because some function parameters require values _without_ leading or trailing whitespaces.
The following example creates an array of timeframe strings by splitting the value of a text area input based on its comma characters. Within a loop, the script uses each element from the array in a time() call to retrieve an opening time, then concatenates a formatted date and time with the `displayText`.
Although each item listed in the default string represents a valid timeframe, the time() call causes a runtime error. The script splits the value only by its commas, resulting in a _leading space_ in each `timeframes` element after the first, and the time() function _does not_ allow whitespaces in its `timeframe` argument.
If the user enables the input to trim the input string (which is off by default), the script uses str.trim() to remove surrounding whitespaces from the time() callâ€™s argument and prevent the formatting issue and the runtime error.
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("InvalidÂ argumentsÂ withÂ whitespacesÂ demo",Â overlayÂ =Â true)  
  
//@variableÂ AÂ stringÂ containingÂ aÂ comma-separatedÂ listÂ ofÂ timeframes.Â   
stringÂ timeframesInputÂ =Â input.text_area("1,Â 5,Â 15,Â 30,Â 60,Â 240,Â 720,Â 1D",Â "Timeframes")  
  
//@variableÂ AÂ booleanÂ variableÂ thatÂ definesÂ whetherÂ toÂ trimÂ theÂ inputÂ string.  
boolÂ doTrimInputÂ =Â input.bool(false,Â "TrimÂ theÂ \"Timeframes\"Â inputÂ string")  
  
//@variableÂ AnÂ arrayÂ ofÂ timeframeÂ substrings.  
varÂ array<string>Â timeframesÂ =Â str.split(timeframesInput,Â ",")  
  
//@variableÂ AÂ concatenatedÂ stringÂ containingÂ formattedÂ datesÂ andÂ timesÂ forÂ eachÂ valueÂ inÂ theÂ `timeframes`Â array.  
stringÂ displayTextÂ =Â "OpeningÂ times:"  
  
forÂ timeframeÂ inÂ timeframes  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `timeframe`Â stringÂ withÂ surroundingÂ whitespacesÂ removed.Â   
Â Â Â Â stringÂ trimmedTimeframeÂ =Â str.trim(timeframe)  
Â Â Â Â //@variableÂ TheÂ UNIXÂ timestampÂ ofÂ theÂ bar'sÂ openingÂ timeÂ onÂ theÂ timeframe.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ callÂ causesÂ aÂ runtimeÂ errorÂ ifÂ theÂ inputÂ stringÂ isÂ notÂ trimmed,Â becauseÂ theÂ argumentÂ contains  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â aÂ leadingÂ whitespaceÂ (e.g.,Â "Â 5"),Â whichÂ isÂ anÂ *unsupportedÂ format*Â forÂ timeframeÂ strings.Â Â   
Â Â Â Â intÂ timestampÂ =Â time(doTrimInputÂ ?Â trimmedTimeframeÂ :Â timeframe)  
Â Â Â Â //Â AddÂ aÂ newÂ textÂ lineÂ containingÂ theÂ `timestamp`Â formattedÂ asÂ aÂ dateÂ andÂ timeÂ inÂ theÂ exchangeÂ timeÂ zone.Â   
Â Â Â Â displayTextÂ +=Â "\n"Â +Â timeframeÂ +Â str.format_time(timestamp,Â "Â yyyy-MM-dd,Â HH:mm:ss")  
  
//Â DrawÂ aÂ labelÂ atÂ theÂ bar'sÂ `high`Â withÂ aÂ tooltipÂ showingÂ theÂ `displayText`.Â   
label.new(bar_index,Â high,Â styleÂ =Â label.style_label_down,Â tooltipÂ =Â displayText)  
`
### Repeating sequences
The str.repeat() function creates a â€œstringâ€ value that _repeats_ a `source` stringâ€™s character sequence a specified number of times, providing a convenient way to construct strings with repetitive character patterns. Below is the functionâ€™s signature:
```

str.repeat(source, repeat, separator) â†’ string

```

Where:
  * `source` is the â€œstringâ€ value containing the character sequence to repeat in the result.
  * `repeat` is an â€œintâ€ value specifying the number of times the function repeats the `source` sequence. If the value is 0, the function returns an empty string.
  * `separator` is an optional â€œstringâ€ value containing a character sequence to _insert_ between each repeated instance of the `source` sequence. The default value is an empty string, meaning the function repeats the `source` sequence _without_ inserting additional characters.


The following script formats two numbers â€” the ohlc4 price and its Simple Moving Average â€” with a variable number of fractional digits. The minimum and maximum number of fractional digits are set by user inputs. The script uses a str.repeat() call to repeat `0` characters to create a pattern for the _required_ digits, and another call that repeats `#` characters to create a pattern for the _optional_ digits, which are displayed only if they are nonzero. The script then concatenates these patterns into one pattern and uses that in a str.format() call to format the two numbers.
The script calls log.info() to log the constructed `formatString` on the first bar, and it displays the formatted results for each bar using labels:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("RepeatingÂ sequencesÂ demo",Â overlayÂ =Â true)  
  
//@variableÂ TheÂ minimumÂ numberÂ ofÂ fractionalÂ digitsÂ inÂ theÂ numericÂ strings.  
intÂ minPrecisionInputÂ =Â input.int(2,Â "MinÂ precision",Â 0,Â 16)  
//@variableÂ TheÂ maximumÂ numberÂ ofÂ fractionalÂ digitsÂ inÂ theÂ numericÂ strings.Â   
intÂ maxPrecisionInputÂ =Â input.int(8,Â "MaxÂ precision",Â 0,Â 16)  
  
//Â RaiseÂ anÂ errorÂ ifÂ theÂ `maxPrecisionInput`Â isÂ lessÂ thanÂ theÂ `minPrecisionInput`.  
ifÂ maxPrecisionInputÂ <Â minPrecisionInput  
Â Â Â Â runtime.error("TheÂ 'MaxÂ precision'Â cannotÂ beÂ lessÂ thanÂ theÂ 'MinÂ precision.")  
  
//@variableÂ AÂ stringÂ containingÂ theÂ `0`Â characterÂ repeatedÂ `minPrecisionInput`Â times.Â   
varÂ stringÂ requiredDigitsÂ =Â str.repeat("0",Â minPrecisionInput)  
//@variableÂ AÂ stringÂ containingÂ theÂ `#`Â characterÂ repeatedÂ `maxPrecisionInputÂ -Â minPrecisionInput`Â times.Â   
varÂ stringÂ extraDigitsÂ =Â str.repeat("#",Â maxPrecisionInputÂ -Â minPrecisionInput)  
  
//@variableÂ AÂ stringÂ representingÂ aÂ formattingÂ patternÂ forÂ numericÂ strings.Â   
//Â Â Â Â Â Â Â Â Â Â WithÂ defaultÂ inputs,Â theÂ valueÂ isÂ `"0.00######"`,Â meaningÂ twoÂ requiredÂ digitsÂ andÂ sixÂ nonzeroÂ extraÂ digits.Â   
varÂ stringÂ formatPatternÂ =Â "0."Â +Â requiredDigitsÂ +Â extraDigits  
  
//@variableÂ AÂ formattingÂ stringÂ thatÂ containsÂ twoÂ placeholdersÂ forÂ theÂ `formatPattern`Â forÂ numericÂ values.Â   
varÂ stringÂ formatStringÂ =Â str.format("OHLC4:Â '{'0,number,{0}'}',Â MA:Â '{'1,number,{0}'}'",Â formatPattern)  
  
//Â LogÂ theÂ `formatString`Â valueÂ onÂ theÂ firstÂ bar.  
ifÂ barstate.isfirst  
Â Â Â Â log.info(formatString)  
  
//Â DrawÂ aÂ labelÂ toÂ showÂ theÂ bar'sÂ formattedÂ result.  
label.new(bar_index,Â high,Â str.format(formatString,Â ohlc4,Â ta.sma(ohlc4,Â 20)),Â sizeÂ =Â 18)  
`
Note that:
  * The apostrophe (`'`) in the str.format() call serves as a _quote character_ , **not** a literal character. The `formatString` uses the apostrophe to quote curly brackets (`{` and `}`), treating them as literal characters instead of direct placeholder markers.


The example below demonstrates a more creative use of str.repeat(). This script generates an ASCII art representation of the Pine Script logo using alternating sequences of repeated `.` (period) and `@` (at) characters. The user-defined `makeLine()` function calls str.repeat() seven times to create the repeated sequences, then formats their results into a single â€œstringâ€ value with a str.format() call. On the first bar, the script formats the results of several `makeLine()` calls into a multiline string and displays the result in a single-cell table in the chartâ€™s top-right corner:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("ASCIIÂ artÂ fromÂ repeatedÂ sequencesÂ demo",Â overlayÂ =Â true)  
  
//@functionÂ CreatesÂ aÂ stringÂ containingÂ alternatingÂ sequencesÂ ofÂ repeatedÂ `.`Â andÂ `@`Â charactersÂ withÂ `\n`Â atÂ theÂ end.  
//Â Â Â Â Â Â Â Â Â Â EachÂ `dot*`Â argumentÂ definesÂ aÂ sequenceÂ ofÂ repeatedÂ `.`Â characters,Â andÂ eachÂ `at*`Â argumentÂ definesÂ a  
//Â Â Â Â Â Â Â Â Â Â sequenceÂ ofÂ repeatedÂ `@`Â characters.Â TheÂ functionÂ formatsÂ theÂ repeatedÂ sequencesÂ fromÂ `str.repeat()`Â callsÂ   
//Â Â Â Â Â Â Â Â Â Â intoÂ aÂ singleÂ string,Â inÂ theÂ orderÂ ofÂ theÂ parameters.  
//Â Â Â Â Â Â Â Â Â Â ForÂ example,Â `makeLine(6,Â 5,Â 4,Â 3,Â 2)`Â returnsÂ `"......@@@@@....@@@..\n"`.  
makeLine(intÂ dot1Â =Â 0,Â intÂ at1Â =Â 0,Â intÂ dot2Â =Â 0,Â intÂ at2Â =Â 0,Â intÂ dot3Â =Â 0,Â intÂ at3Â =Â 0,Â intÂ dot4Â =Â 0)Â =>  
Â Â Â Â stringÂ resultÂ =Â str.format(  
Â Â Â Â Â Â Â Â Â "{0}{1}{2}{3}{4}{5}{6}\n",  
Â Â Â Â Â Â Â Â Â str.repeat(".",Â dot1),Â str.repeat("@",Â at1),Â str.repeat(".",Â dot2),Â str.repeat("@",Â at2),Â   
Â Â Â Â Â Â Â Â Â str.repeat(".",Â dot3),Â str.repeat("@",Â at3),Â str.repeat(".",Â dot4)Â   
Â Â Â Â Â )  
Â Â Â Â result  
  
ifÂ barstate.isfirst  
Â Â Â Â //@variableÂ AÂ stringÂ representingÂ theÂ PineÂ logoÂ usingÂ severalÂ linesÂ ofÂ differentÂ repeatedÂ `.`Â andÂ `@`Â sequences.Â   
Â Â Â Â stringÂ asciiArtÂ =Â str.format(  
Â Â Â Â Â Â Â Â Â "{0}{1}{2}{3}{4}{5}{6}{7}{8}{9}{10}{11}{12}{13}{14}{15}{16}{17}"Â +  
Â Â Â Â Â Â Â Â Â "{18}{19}{20}{21}{22}{23}{24}{25}{26}{27}{28}{29}{30}{31}{32}{33}",Â   
Â Â Â Â Â Â Â Â Â makeLine(80),Â makeLine(80),Â makeLine(38,Â 6,Â 36),Â makeLine(37,Â 8,Â 35),Â makeLine(35,Â 12,Â 33),Â   
Â Â Â Â Â Â Â Â Â makeLine(34,Â 15,Â 31),Â makeLine(33,Â 7,Â 2,Â 7,Â 31),Â makeLine(31,Â 8,Â 4,Â 8,Â 29),Â makeLine(29,Â 8,Â 8,Â 8,Â 27),Â   
Â Â Â Â Â Â Â Â Â makeLine(28,Â 8,Â 10,Â 9,Â 25),Â makeLine(27,Â 7,Â 14,Â 8,Â 24),Â makeLine(25,Â 8,Â 17,Â 8,Â 22),Â makeLine(24,Â 8,Â 19,Â 8,Â 21),Â   
Â Â Â Â Â Â Â Â Â makeLine(23,Â 7,Â 22,Â 9,Â 19),Â makeLine(21,Â 17,Â 16,Â 9,Â 17),Â makeLine(20,Â 20,Â 16,Â 8,Â 16),Â   
Â Â Â Â Â Â Â Â Â makeLine(18,Â 25,Â 14,Â 9,Â 14),Â makeLine(18,Â 14,Â 3,Â 10,Â 13,Â 8,Â 14),Â makeLine(18,Â 8,Â 11,Â 10,Â 9,Â 10,Â 14),Â   
Â Â Â Â Â Â Â Â Â makeLine(39,Â 10,Â 4,Â 12,Â 15),Â makeLine(29,Â 6,Â 7,Â 20,Â 18),Â makeLine(24,Â 14,Â 6,Â 15,Â 21),Â   
Â Â Â Â Â Â Â Â Â makeLine(20,Â 21,Â 5,Â 10,Â 24),Â makeLine(18,Â 25,Â 5,Â 5,Â 5,Â 6,Â 16),Â makeLine(17,Â 28,Â 10,Â 10,Â 15),Â   
Â Â Â Â Â Â Â Â Â makeLine(16,Â 32,Â 4,Â 14,Â 14),Â makeLine(14,Â 54,Â 12),Â makeLine(13,Â 56,Â 11),Â makeLine(12,Â 58,Â 10),Â   
Â Â Â Â Â Â Â Â Â makeLine(10,Â 62,Â 8),Â makeLine(9,Â 64,Â 7),Â makeLine(9,Â 64,Â 7),Â makeLine(80),Â makeLine(80)  
Â Â Â Â Â )  
  
Â Â Â Â //@variableÂ AÂ single-cellÂ tableÂ toÂ displayÂ theÂ `asciiArt`Â value.  
Â Â Â Â tableÂ tÂ =Â table.new(position.top_right,Â 1,Â 1,Â frame_colorÂ =Â chart.fg_color,Â frame_widthÂ =Â 1)  
Â Â Â Â //Â InitializeÂ aÂ left-alignedÂ cellÂ withÂ monospaceÂ fontÂ forÂ properÂ alignment.Â Â   
Â Â Â Â t.cell(  
Â Â Â Â Â Â Â Â Â 0,Â 0,Â asciiArt,Â text_colorÂ =Â chart.fg_color,Â text_halignÂ =Â text.align_left,Â text_sizeÂ =Â 6,Â   
Â Â Â Â Â Â Â Â Â text_font_familyÂ =Â font.family_monospace  
Â Â Â Â Â )  
`
Note that:
  * The table.cell() call uses text.align_left as the `text_halign` argument and font.family_monospace as the `text_font_family` argument to align the text lines to the _left_ with relatively uniform character width.
  * The formatted string from each `makeLine()` call uses the `\n` escape sequence at the end to add a line terminator.

## String inspection and extraction
Several built-in `str.*()` functions allow scripts to measure a â€œstringâ€ value, check for substrings and retrieve their positions, split a string into several substrings, and extract substrings based on positions or match patterns. These functions include str.length(), str.contains(), str.startswith(), str.endswith(), str.split(), str.pos(), str.substring(), and str.match().
The sections below explain these functions and some helpful techniques to use them effectively.
### Counting characters and substrings
The str.length() function measures the length of a specified â€œstringâ€ value, returning an â€œintâ€ value representing the number of characters in the argumentâ€™s character sequence. It has the following signature:
```

str.length(string) â†’ int

```

This function detects _every_ character within a â€œstringâ€ valueâ€™s sequence, even those that are hard to see, such as leading or repeated spaces, line terminators, and invisible characters like U+200B (Zero Width Space).
For example, this simple script declares two variables with assigned literal strings and measures their length. The script creates the first â€œstringâ€ value using _Em Space_ characters (U+2003), and creates the second using _En Space_ characters (U+2002) instead. It measures the length of both strings with str.length(), creates modified strings with the `"__"` parts replaced by the length values, then concatenates the results for display in a single-cell table.
Although the two strings look identical in the output, their lengths differ because one En Space is equivalent to _half_ the width of one Em Space, meaning the second string must include _two En Spaces_ between each word to match the width of each Em Space in the first string:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("CountingÂ charactersÂ demo")  
  
ifÂ barstate.isfirst  
Â Â Â Â //@variableÂ AÂ single-cellÂ tableÂ toÂ displayÂ text.Â   
Â Â Â Â varÂ tableÂ displayÂ =Â table.new(position.middle_center,Â 1,Â 1,Â color.teal)  
  
Â Â Â Â //@variableÂ AÂ literalÂ stringÂ thatÂ usesÂ oneÂ EmÂ SpaceÂ (U+2003)Â betweenÂ eachÂ word.Â   
Â Â Â Â stringÂ testString1Â =Â "Thisâ€ƒ'string'â€ƒcontains\n__â€ƒcharacters."  
  
Â Â Â Â //@variableÂ AÂ literalÂ stringÂ thatÂ usesÂ twoÂ EnÂ SpacesÂ (U+2002)Â betweenÂ eachÂ word.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â AnÂ EnÂ SpaceÂ isÂ halfÂ theÂ widthÂ ofÂ anÂ EmÂ Space,Â soÂ thisÂ stringÂ containsÂ threeÂ extraÂ charactersÂ   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â toÂ matchÂ theÂ widthsÂ ofÂ eachÂ EmÂ spaceÂ inÂ `testString1`Â andÂ produceÂ anÂ identicalÂ output.  
Â Â Â Â stringÂ testString2Â =Â "Thisâ€‚â€‚'string'â€‚â€‚contains\n__â€‚â€‚characters."  
Â Â Â Â   
Â Â Â Â //Â CountÂ theÂ numberÂ ofÂ charactersÂ inÂ `testString1`Â andÂ `testString2`.  
Â Â Â Â intÂ length1Â =Â str.length(testString1)  
Â Â Â Â intÂ length2Â =Â str.length(testString2)  
Â Â Â Â //Â ReplaceÂ theÂ "__"Â inÂ `testString1`Â andÂ `testString2`Â withÂ stringÂ representationsÂ ofÂ `length1`Â andÂ `length2`.  
Â Â Â Â testString1Â :=Â str.replace(testString1,Â "__",Â str.tostring(length1))  
Â Â Â Â testString2Â :=Â str.replace(testString2,Â "__",Â str.tostring(length2))  
Â Â Â Â   
Â Â Â Â //Â ConcatenateÂ bothÂ stringsÂ andÂ twoÂ newlineÂ characters,Â thenÂ displayÂ theÂ resultÂ inÂ theÂ table'sÂ cell.Â Â   
Â Â Â Â stringÂ displayStringÂ =Â testString1Â +Â "\n\n"Â +Â testString2  
Â Â Â Â display.cell(0,Â 0,Â displayString,Â text_colorÂ =Â color.white,Â text_sizeÂ =Â 50,Â text_halignÂ =Â text.align_left)  
`
Note that:
  * A simple way to verify the added characters is to _split_ the `testString2` value into an array of substrings with str.split() and inspect the arrayâ€™s elements. See the Splitting strings section to learn more about this function.


The str.length() function is also useful for counting the number of _substrings_ of any size contained within a stringâ€™s sequence, which is helpful information when replacing substrings or performing custom routines that depend on recurring characters.
The following example defines a `countSubstrings()` function, which uses str.replace_all() and str.length() to count the number of times a `target` substring occurs within a specified `source` value. The function creates a modified copy of the `source` with all instances of the `target` removed, then calls str.length() to measure the length of each separate string. It calculates the number of `target` occurrences by dividing the length difference in the original and reduced strings by the length of the substring.
The script uses str.repeat() to generate a â€œstringâ€ value that repeats the sequence `aba` a pseudorandom number of times with `baab` inserted between each instance, then counts all occurrences of the substring `ab` in the result with a `countSubstrings()` call. It then displays a formatted message containing the repeated sequence and the total number of `ab` substrings in the Pine Logs pane:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("CountingÂ substringsÂ demo",Â overlayÂ =Â true)  
  
//@functionÂ CountsÂ theÂ numberÂ ofÂ timesÂ aÂ `target`Â substringÂ occursÂ withinÂ theÂ specifiedÂ `source`.Â   
countSubstrings(stringÂ source,Â stringÂ target)Â =>  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `source`Â stringÂ withÂ allÂ instancesÂ ofÂ theÂ `target`Â removed.Â   
Â Â Â Â stringÂ reducedÂ =Â str.replace_all(source,Â target,Â "")  
Â Â Â Â //Â CountÂ theÂ charactersÂ inÂ theÂ `source`,Â `target`,Â andÂ `reduced`Â strings.Â Â   
Â Â Â Â intÂ sourceLengthÂ Â =Â str.length(source)  
Â Â Â Â intÂ targetLengthÂ Â =Â str.length(target)  
Â Â Â Â intÂ reducedLengthÂ =Â str.length(reduced)  
Â Â Â Â //Â CalculateÂ theÂ differenceÂ betweenÂ `sourceLength`Â andÂ `reducedLength`Â relativeÂ toÂ theÂ `targetLength`.  
Â Â Â Â //Â ThisÂ valueÂ representsÂ theÂ numberÂ ofÂ `target`Â substringsÂ insideÂ theÂ originalÂ `source`.Â   
Â Â Â Â (sourceLengthÂ -Â reducedLength)Â /Â targetLength  
  
//@variableÂ AÂ stringÂ containingÂ `aba`Â repeatedÂ aÂ pseudorandomÂ numberÂ ofÂ timesÂ withÂ `baab`Â insertedÂ betweenÂ eachÂ instance.  
stringÂ randStringÂ =Â str.repeat("aba",Â int(math.random(1,Â 8)),Â "baab")  
  
//@variableÂ TheÂ numberÂ ofÂ timesÂ theÂ `ab`Â sequenceÂ occursÂ inÂ theÂ `randString`.  
intÂ countÂ =Â countSubstrings(randString,Â "ab")  
  
//Â LogÂ aÂ formattedÂ messageÂ containingÂ theÂ `randString`Â andÂ `count`Â valuesÂ inÂ theÂ PineÂ LogsÂ pane.  
log.info("randString:Â {0},Â Â count:Â {1,number,#}",Â randString,Â count)  
`
Note that:
  * This script uses the _second overload_ of log.info(), which shares the same signature as str.format() but logs a formatted message instead of returning a value. See the Pine Logs section of the Debugging page to learn more about the `log*()` functions.


### Checking for substrings
The str.contains() function searches a `source` string for a specified substring, returning a â€œboolâ€ value representing whether it found the substring. Two similar functions, str.startswith() and str.endswith(), check whether the `source` _starts_ and _ends_ with a specified substring.
These functions have the following signatures:
```

str.contains(source, str) â†’ bool


str.startswith(source, str) â†’ bool


str.endswith(source, str) â†’ bool

```

Where:
  * `source` is the â€œstringâ€ value that the function searches to find the substring.
  * `str` is a â€œstringâ€ value containing the substring to find in the `source`. The str.contains() function returns `true` if the `source` contains at least one instance of the substring. The str.startswith() function returns `true` only if the `source` starts with the substring, even if the substring exists elsewhere in the character sequence. Likewise, str.endswith() returns `true` only if the `source` ends with the substring.


These functions are convenient when a script needs to check whether a substring exists but does not require the substring in additional calculations. Programmers often use these functions in conditional logic to control script behaviors based on a â€œstringâ€ valueâ€™s contents.
The following script creates a spread symbol string from two symbol inputs and requests price information from that spread symbol using a request.security() call. Before executing the request, the script calls str.startswith() to check whether the `spreadInput` value starts with a leading space and forward slash (`/`), indicating that the first input is _empty_. If the call returns `true`, the script replaces the missing symbol in the â€œstringâ€ value with the chartâ€™s symbol to prevent errors.
The script then plots the retrieved data as candles in a separate pane. The colors of the candles change if the chart is in Bar Replay mode. The script tests for Bar Replay mode by searching for the `replay` substring in the chartâ€™s ticker identifier (syminfo.tickerid) using a str.contains() call:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("CheckingÂ forÂ substringsÂ demo")  
  
//@variableÂ AÂ spreadÂ symbolÂ createdÂ fromÂ twoÂ symbolÂ inputs.Â TheÂ firstÂ inputÂ isÂ anÂ emptyÂ stringÂ byÂ default.  
varÂ stringÂ spreadInputÂ =Â input.symbol("",Â "SymbolÂ 1")Â +Â "Â /Â "Â +Â input.symbol("BATS:SPY",Â "SymbolÂ 2")  
  
//@variableÂ IsÂ `true`Â ifÂ theÂ `spreadInput`Â startsÂ withÂ `Â /`,Â meaningÂ theÂ firstÂ inputÂ isÂ empty.Â   
varÂ boolÂ missingNumeratorÂ =Â str.startswith(spreadInput,Â "Â /")  
//@variableÂ AÂ copyÂ ofÂ theÂ spreadInput`Â thatÂ insertsÂ theÂ chart'sÂ standardÂ tickerÂ IDÂ whenÂ `missingNumerator`Â isÂ `true`.Â   
varÂ stringÂ spreadÂ =Â missingNumeratorÂ ?Â str.replace(spreadInput,Â "Â /",Â ticker.standard()Â +Â "Â /")Â :Â spreadInput  
  
//Â RequestÂ aÂ tupleÂ ofÂ OHLCÂ dataÂ fromÂ theÂ `spread`Â context.Â   
[o,Â h,Â l,Â c]Â =Â request.security("Â "Â +Â spread,Â "",Â [open,Â high,Â low,Â close])  
  
//@variableÂ IsÂ `true`Â ifÂ theÂ chart'sÂ tickerÂ IDÂ containsÂ `replay`,Â meaningÂ BarÂ ReplayÂ modeÂ isÂ active.Â   
varÂ boolÂ isReplayÂ =Â str.contains(syminfo.tickerid,Â "replay")  
  
//Â DefineÂ variablesÂ toÂ holdÂ colorsÂ forÂ upÂ andÂ downÂ candles.Â TheirÂ valuesÂ dependÂ onÂ whetherÂ `isReplay`Â isÂ `true`.  
varÂ colorÂ upColorÂ =Â isReplayÂ ?Â color.blueÂ :Â color.teal  
varÂ colorÂ dnColorÂ =Â isReplayÂ ?Â color.maroonÂ :Â color.red  
  
//Â PlotÂ theÂ candlesÂ inÂ aÂ separateÂ pane.Â   
plotcandle(o,Â h,Â l,Â c,Â "SpreadÂ candles",Â cÂ >Â oÂ ?Â upColorÂ :Â dnColor)  
  
//Â LogÂ theÂ originalÂ `spreadInput`,Â theÂ finalÂ `spread`Â value,Â andÂ theÂ `isReplay`Â value`Â inÂ theÂ PineÂ LogsÂ pane.  
ifÂ barstate.isfirst  
Â Â Â Â log.info("\n\nOriginalÂ input:Â {0}\nFinalÂ spread:Â {1}\nReplayÂ chart:Â {2}",Â spreadInput,Â spread,Â isReplay)  
`
Note that:
  * We used `" /"` as the substring value in the str.startswith() call because an empty string does _not_ detect the empty input value. When the substring specified in a str.contains(), str.startswith(), or str.endswith() call is empty, the function always returns `true` because the argument can match _any position_ in a stringâ€™s sequence.


### Splitting strings
The str.split() function splits a single â€œstringâ€ value into one or more substrings based on a `separator` substring in the valueâ€™s character sequence, then collects the results in an array. Below is the functionâ€™s signature:
```

str.split(string, separator) â†’ array<string>

```

Where:
  * The specified `string` is the value to divide into substrings.
  * The `separator` is a â€œstringâ€ value containing the characters that divide each substring. The resulting array does _not_ include the separator in its elements. If the value is empty, the function splits the string into single-character substrings.


The str.split() function returns an array of strings, unlike the other `str.*()` functions. Scripts can use `array.*()` functions on these arrays, or iterate through them directly with forâ€¦in loops. Programmers often use str.split() to process â€œstringâ€ inputs and parameters that represent _lists_ of arguments for dynamic requests and other calculations.
The following script requests data from several contexts based on a text area input containing a comma-separated list of symbols. First, the script splits the input value based on its commas with str.split() to construct an array of symbol strings. Then, it uses a forâ€¦in loop to iterate over the arrayâ€™s contents, request data for each symbol, and populate a table with the results. Additionally, the tableâ€™s first row contains a â€œstringâ€ representation of the array of symbols:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("SplittingÂ stringsÂ demo")  
  
//@variableÂ AÂ stringÂ containingÂ aÂ listÂ ofÂ symbolsÂ separatedÂ byÂ commasÂ andÂ optionalÂ spaces.Â   
stringÂ symbolListInputÂ =Â input.text_area("AAPL,Â NVDA,Â MSFT,Â AMZN,Â SPY")  
  
//@variableÂ AnÂ arrayÂ ofÂ symbolsÂ createdÂ byÂ splittingÂ theÂ `symbolListInput`Â byÂ itsÂ commas.Â   
varÂ array<string>Â symbolsArrayÂ =Â str.split(symbolListInput,Â ",")  
  
ifÂ barstate.islast  
Â Â Â Â //@variableÂ AÂ two-columnÂ tableÂ withÂ aÂ rowÂ forÂ eachÂ `symbolsArray`Â item.Â   
Â Â Â Â varÂ tableÂ displayÂ =Â table.new(position.middle_center,Â 2,Â symbolsArray.size()Â +Â 1)  
Â Â Â Â   
Â Â Â Â //Â InitializeÂ aÂ mergedÂ cellÂ toÂ showÂ theÂ `symbolsArray`.Â   
Â Â Â Â display.cell(  
Â Â Â Â Â Â Â Â Â 0,Â 0,Â "Symbols:\n"Â +Â str.tostring(symbolsArray),Â bgcolorÂ =Â color.blue,Â text_colorÂ =Â color.white,  
Â Â Â Â Â Â Â Â Â text_sizeÂ =Â 30  
Â Â Â Â Â )  
Â Â Â Â display.merge_cells(0,Â 0,Â 1,Â 0)  
  
Â Â Â Â //Â LoopÂ throughÂ theÂ `symbolsArray`.Â   
Â Â Â Â forÂ [i,Â symbol]Â inÂ symbolsArray  
Â Â Â Â Â Â Â Â //@variableÂ TheÂ `close`Â valueÂ requestedÂ forÂ theÂ `symbol`Â onÂ theÂ chart'sÂ timeframe.Â   
Â Â Â Â Â Â Â Â floatÂ requestedValueÂ =Â request.security(symbol,Â timeframe.period,Â close)  
Â Â Â Â Â Â Â Â //Â InitializeÂ aÂ cellÂ forÂ theÂ `symbol`Â andÂ aÂ "string"Â representingÂ theÂ `requestedValue`.Â   
Â Â Â Â Â Â Â Â display.cell(0,Â iÂ +Â 1,Â symbol,Â text_colorÂ =Â chart.fg_color,Â text_sizeÂ =Â 20)  
Â Â Â Â Â Â Â Â display.cell(1,Â iÂ +Â 1,Â str.tostring(requestedValue),Â text_colorÂ =Â chart.fg_color,Â text_sizeÂ =Â 20)  
`
Note that:
  * The symbol strings in the array contain _extra whitespaces_ , which are not visible in the table. However, in contrast to some other function parameters, the `symbol` parameter of request.security() ignores leading and trailing whitespaces in its argument.
  * The script uses str.tostring() and concatenation to create the strings used for the tableâ€™s text.
  * This script can fetch data from other contexts within a loop using â€œseries stringâ€ `symbol` values because scripts allow dynamic requests by default. See the Dynamic requests section of the Other timeframes and data page for more information.


### Locating and retrieving substrings
The str.pos() function searches a `source` string for the _first_ occurrence of a specified substring and returns an â€œintâ€ value representing the _position_ of its initial character boundary. The functionâ€™s signature is as follows:
```

str.pos(source, str) â†’ int

```

Where:
  * `source` is the â€œstringâ€ value to search for the first occurrence of the `str` substring.
  * `str` is a â€œstringâ€ value representing the substring to locate in the `source`. If the argument is na or an empty â€œstringâ€ value, the function returns 0 (the first possible position).


The str.substring() function retrieves a substring from a `source` value at specified character positions. This function has the following signatures:
```

str.substring(source, begin_pos) â†’ string


str.substring(source, begin_pos, end_pos) â†’ string

```

Where:
  * `source` is the â€œstringâ€ value containing the substring.
  * `begin_pos` is an â€œintâ€ value representing the position of the substringâ€™s first character in the `source`, where the numbering starts from zero. If the value is na, the function sets the initial position to 0. The script raises an error if the specified position is invalid.
  * The `end_pos` is an â€œintâ€ value representing the position _after_ the substringâ€™s last character in the `source`. This position is _exclusive_ , meaning the returned value does **not** contain this positionâ€™s character. If the value is not specified or represents a position outside the stringâ€™s length, the substring includes _all_ characters from the `begin_pos` onward. If the value is less than the `begin_pos`, it causes a runtime error.


For example, the `begin_pos` value of the substring `"Trading"` in the string `"TradingView"` is 0, because the substring starts at the source stringâ€™s _first_ character position. The `end_pos` value is 7, because the substringâ€™s last character (`g`) is at position 6, and `end_pos` represents the position _after_ that character. To retrieve only the first character of a string as a substring, use a call such as `str.substring("TradingView", 0, 1)`.
Programmers often use these functions together by retrieving positional values with str.pos() and then using those values to extract substrings with str.substring() for additional calculations. This technique is an efficient alternative to matching patterns for substrings at specific positions that have unique characters.
The following simple script uses these functions to extract the â€œareaâ€ and â€œlocationâ€ parts of the syminfo.timezone variableâ€™s _IANA identifier_. The script calls str.pos() to get the position of the `/` character in the time zone string, which it assigns to the `dividerPos` variable. Then, it uses that variable in two str.substring() calls. The first call retrieves the substring from position 0 to `dividerPos`, and the second retrieves the substring from the position at `dividerPos + 1` to the end of the string.
The script displays the IANA identifier, the retrieved substrings, and the formatted date and time of the latest execution in a single-cell table on the last bar:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("LocatingÂ andÂ retrievingÂ substringsÂ demo",Â overlayÂ =Â true)  
  
ifÂ barstate.islast  
Â Â Â Â //@variableÂ AÂ single-cellÂ tableÂ toÂ showÂ theÂ `displayText`.Â   
Â Â Â Â varÂ tableÂ displayÂ =Â table.new(position.bottom_right,Â 1,Â 1,Â frame_colorÂ =Â chart.fg_color,Â frame_widthÂ =Â 1)  
  
Â Â Â Â //@variableÂ TheÂ positionÂ ofÂ theÂ `/`Â characterÂ inÂ theÂ exchangeÂ timeÂ zone'sÂ IANAÂ identifier.  
Â Â Â Â varÂ intÂ dividerPosÂ =Â str.pos(syminfo.timezone,Â "/")  
Â Â Â Â //@variableÂ TheÂ `syminfo.timezone`Â substringÂ fromÂ positionÂ 0Â toÂ `dividerPos`.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ substringÂ epresentsÂ theÂ "area"Â partÂ ofÂ theÂ timeÂ zoneÂ identifier.Â Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â TheÂ characterÂ atÂ `dividerPos`Â isÂ notÂ included.Â   
Â Â Â Â varÂ stringÂ areaStringÂ =Â str.substring(syminfo.timezone,Â 0,Â dividerPos)  
  
Â Â Â Â //@variableÂ TheÂ `syminfo.timezone`Â substringÂ fromÂ `dividerPosÂ +Â 1`Â toÂ theÂ endÂ ofÂ theÂ string,Â withoutÂ lowÂ lines.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ substringÂ representsÂ theÂ "location"Â partÂ ofÂ theÂ timeÂ zoneÂ identifier.Â   
Â Â Â Â varÂ stringÂ locationStringÂ =Â str.replace_all(str.substring(syminfo.timezone,Â dividerPosÂ +Â 1),Â "_",Â "Â ")  
  
Â Â Â Â //@variableÂ AÂ stringÂ representingÂ theÂ latestÂ execution'sÂ dateÂ andÂ timeÂ inÂ theÂ chart'sÂ timeÂ zone.  
Â Â Â Â stringÂ formattedTimeÂ =Â str.format_time(timenow,Â "HH:mm:ssÂ 'on'Â MMMÂ d,Â yyyy")  
  
Â Â Â Â //@variableÂ AÂ formattedÂ stringÂ containingÂ `syminfo.timezone`,Â `areaString`,Â `locationString`,Â andÂ `formattedTime`.  
Â Â Â Â stringÂ displayTextÂ =Â str.format(  
Â Â Â Â Â Â Â Â Â "IANAÂ identifier:Â {0}\n\nArea:Â {1}\nLocation:Â {2}\n\nTimeÂ ofÂ latestÂ tick:Â {3}",  
Â Â Â Â Â Â Â Â Â syminfo.timezone,Â areaString,Â locationString,Â formattedTimeÂ   
Â Â Â Â Â )  
Â Â Â Â //Â InitializeÂ theÂ tableÂ cellÂ withÂ theÂ `displayText`.  
Â Â Â Â display.cell(0,Â 0,Â displayText,Â text_sizeÂ =Â 24,Â text_colorÂ =Â chart.fg_color)  
`
Note that:
  * The first str.substring() call does _not_ include the character at the position specified by `dividerPos`. Its result contains only the characters from position 0 to `dividerPos - 1`.


Itâ€™s important to emphasize that the str.pos() function only finds the _first_ occurrence of a specified substring. However, in some cases, programmers might require the positions of the substringâ€™s _other_ occurrences. One way to achieve this result is by repeatedly _reducing_ a â€œstringâ€ value with str.substring() and locating the substring in the new value with str.pos().
The advanced example script below contains a `getPositions()` function that returns an array containing every `substring` position within a specified `source`. The function first uses str.pos() to get the position of the first `substring` and creates an array containing that value with array.from(). If the initial position is not na, the function removes all characters up to the substringâ€™s end position with str.substring(). Then, it executes a forâ€¦in loop that repeatedly locates the substring, pushes the calculated position into the array, and reduces the character sequence. The loop stops only after the array contains the position of every substring in the `source` value.
On the first bar, the script uses the function to analyze substring occurrences in four arbitrarily selected strings, then logs formatted messages containing the results in the Pine Logs pane:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("LocatingÂ multipleÂ substringsÂ demo",Â overlayÂ =Â true)  
  
getPositions(stringÂ source,Â stringÂ substring)Â =>  
Â Â Â Â //@variableÂ TheÂ positionÂ ofÂ theÂ firstÂ occurrenceÂ ofÂ theÂ `substring`.Â   
Â Â Â Â intÂ firstPosÂ =Â str.pos(source,Â substring)  
Â Â Â Â //@variableÂ AnÂ arrayÂ containingÂ theÂ startingÂ positionÂ ofÂ eachÂ `substring`Â occurrenceÂ inÂ theÂ `source`.Â   
Â Â Â Â array<int>Â positionsÂ =Â array.from(firstPos)  
  
Â Â Â Â //Â SearchÂ forÂ extraÂ positionsÂ ifÂ `firstPos`Â isÂ notÂ `na`.  
Â Â Â Â ifÂ notÂ na(firstPos)  
Â Â Â Â Â Â Â Â //@variableÂ TheÂ lengthÂ ofÂ theÂ `substring`.Â   
Â Â Â Â Â Â Â Â intÂ substringLengthÂ =Â str.length(substring)  
Â Â Â Â Â Â Â Â //@variableÂ AÂ substringÂ ofÂ `source`Â fromÂ `firstPosÂ +Â substringLength`Â onward.Â   
Â Â Â Â Â Â Â Â stringÂ reducedÂ =Â str.substring(source,Â firstPosÂ +Â substringLength)  
  
Â Â Â Â Â Â Â Â //Â LoopÂ throughÂ theÂ `positions`Â array.Â   
Â Â Â Â Â Â Â Â forÂ posÂ inÂ positions  
Â Â Â Â Â Â Â Â Â Â Â Â //@variableÂ TheÂ endÂ boundaryÂ positionÂ ofÂ theÂ firstÂ `substring`Â occurrenceÂ inÂ theÂ `reduced`Â string.Â   
Â Â Â Â Â Â Â Â Â Â Â Â intÂ newPosÂ =Â str.pos(reduced,Â substring)Â +Â substringLength  
Â Â Â Â Â Â Â Â Â Â Â Â //Â AddÂ aÂ newÂ elementÂ toÂ theÂ `positions`Â arrayÂ andÂ reduceÂ theÂ `reduced`Â stringÂ ifÂ `newPos`Â isÂ notÂ `na`.Â   
Â Â Â Â Â Â Â Â Â Â Â Â ifÂ notÂ na(newPos)  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //Â PushÂ `posÂ +Â newPos`Â intoÂ theÂ `positions`Â array,Â allowingÂ anotherÂ iteration.  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //Â TheÂ `newPos`Â isÂ addedÂ toÂ theÂ latestÂ `pos`Â toÂ getÂ theÂ actualÂ positionÂ inÂ theÂ originalÂ `source`.Â Â   
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â positions.push(posÂ +Â newPos)  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â //Â AssignÂ theÂ substringÂ fromÂ `newPos`Â onwardÂ toÂ theÂ `reduced`Â variable.Â   
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â reducedÂ :=Â str.substring(reduced,Â newPos)  
Â Â Â Â positions  
  
ifÂ barstate.isfirst  
Â Â Â Â //Â DefineÂ fourÂ arbitraryÂ strings.  
Â Â Â Â stringÂ testStr1Â =Â "NASDAQ:AAPL"  
Â Â Â Â stringÂ testStr2Â =Â "1234321234321"  
Â Â Â Â stringÂ testStr3Â =Â str.repeat(str.repeat("abc",Â 3,Â ",Â "),Â 2,Â "Â a")  
Â Â Â Â stringÂ testStr4Â =Â str.format_time(time)  
  
Â Â Â Â //Â GetÂ arraysÂ containingÂ theÂ positionsÂ ofÂ variousÂ substringsÂ inÂ theÂ fourÂ testÂ strings.  
Â Â Â Â array<int>Â positions1Â =Â getPositions(testStr1,Â "A")  
Â Â Â Â array<int>Â positions2Â =Â getPositions(testStr2,Â "12")  
Â Â Â Â array<int>Â positions3Â =Â getPositions(testStr3,Â ",Â ")  
Â Â Â Â array<int>Â positions4Â =Â getPositions(testStr4,Â "-")  
  
Â Â Â Â //@variableÂ TheÂ formattingÂ stringÂ forÂ allÂ `log.info()`Â calls.Â TheÂ `{0}`Â placeholderÂ isÂ forÂ apostrophes.Â   
Â Â Â Â stringÂ formatStringÂ =Â "PositionsÂ ofÂ {0}{1}{0}Â inÂ {0}{2}{0}:Â {3}"  
  
Â Â Â Â //Â LogÂ formattedÂ resultsÂ inÂ theÂ PineÂ LogsÂ pane.Â   
Â Â Â Â log.info(formatString,Â "'",Â "A",Â testStr1,Â str.tostring(positions1))  
Â Â Â Â log.info(formatString,Â "'",Â "12",Â testStr2,Â str.tostring(positions2))  
Â Â Â Â log.info(formatString,Â "'",Â ",Â ",Â testStr3,Â str.tostring(positions3))  
Â Â Â Â log.info(formatString,Â "'",Â "-",Â testStr4,Â str.tostring(positions4))  
`
Note that:
  * Although the `positions` array starts with _one_ element, the forâ€¦in loop performs _more than one_ iteration because Pine loops can have dynamic boundaries. After each execution of the array.push() call, the `positions` arrayâ€™s size increases, allowing a _new iteration_. Refer to the Loops page for more information.
  * Each reduced version of the string starts at the position _after_ the last character of the detected substring. The script identifies the end position by adding the substringâ€™s str.length() value to its starting position.


### Matching patterns
Pine scripts can dynamically match and retrieve substrings using the str.match() function. In contrast to the other `str.*()` functions, which only match sequences of literal characters, the str.match() function uses regular expressions (regex) to match variable _character patterns_. The functionâ€™s signature is as follows:
```

str.match(source, regex) â†’ string

```

Where:
  * `source` is the â€œstringâ€ value containing the sequence to match using the regular expression.
  * `regex` is a â€œstringâ€ value representing the regular expression that specifies the _pattern_ to match in the `source`. The function returns the _first substring_ that follows the match pattern. If the regex does not match any substring in the `source`, the function returns an empty string.


TipUsing str.match() requires a basic understanding of regular expressions and how they work. The tables in the next section provide a detailed overview of the syntax supported by Pineâ€™s regex engine to help you make the most of this function.
Because the str.match() function matches _patterns_ in a stringâ€™s character sequence rather than strictly literal characters, a single call to this function can perform a wide range of text-matching tasks that would otherwise require multiple calls to other `str.*()` functions or custom operations.
For example, this script requests data from a FINRA Short Sale Volume series for a specified symbol. It uses separate str.startswith() calls to check whether the symbol string has one of the supported exchange prefixes. It locates and removes the exchange prefix with str.pos() and str.substring(), constructs a FINRA ticker ID with str.format() and logs its value, then executes the request.security() call only if one of the str.startswith() calls returns `true`. The script plots the retrieved data on the chart as columns:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("DetectingÂ substringsÂ withÂ otherÂ functionsÂ demo")  
  
//@variableÂ TheÂ symbolÂ forÂ whichÂ toÂ requestÂ ShortÂ SaleÂ VolumeÂ data.Â   
stringÂ symbolInputÂ =Â input.symbol("NASDAQ:AAPL",Â "Symbol")  
  
//@variableÂ `true`Â ifÂ theÂ `symbolInput`Â startsÂ withÂ `BATS:`,Â `NASDAQ:`,Â `NYSE:`,Â orÂ `AMEX:`.Â Otherwise,Â `false`.  
varÂ boolÂ supportedSymbolÂ =Â str.startswith(symbolInput,Â "BATS:")Â or  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â str.startswith(symbolInput,Â "NASDAQ:")Â or  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â str.startswith(symbolInput,Â "NYSE:")Â or  
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â str.startswith(symbolInput,Â "AMEX:")  
  
//@variableÂ TheÂ requestedÂ FINRAÂ dataÂ ifÂ `supportedSymbol`Â isÂ `true`,Â `na`Â otherwise.  
floatÂ requestedDataÂ =Â ifÂ supportedSymbol  
Â Â Â Â //@variableÂ TheÂ `symbolInput`Â valueÂ withoutÂ theÂ exchangeÂ prefix.  
Â Â Â Â varÂ stringÂ noPrefixÂ =Â str.substring(symbolInput,Â str.pos(symbolInput,Â ":")Â +Â 1)  
Â Â Â Â //@variableÂ AÂ formattedÂ stringÂ representingÂ theÂ tickerÂ IDÂ ofÂ aÂ FINRAÂ ShortÂ SaleÂ VolumeÂ dataset.Â   
Â Â Â Â varÂ stringÂ finraTickerIDÂ =Â str.format("FINRA:{0}_SHORT_VOLUME",Â noPrefix)  
Â Â Â Â //Â LogÂ theÂ `finraTickerID`Â inÂ theÂ PineÂ LogsÂ paneÂ onÂ theÂ firstÂ bar.  
Â Â Â Â ifÂ barstate.isfirst  
Â Â Â Â Â Â Â Â log.info(finraTickerID)  
Â Â Â Â //Â RetrieveÂ theÂ data.Â   
Â Â Â Â request.security(finraTickerID,Â timeframe.isintradayÂ ?Â "1D"Â :Â "",Â close)  
  
//Â PlotÂ theÂ `requestedData`  
plot(requestedData,Â "ShortÂ SaleÂ Volume",Â color.teal,Â 1,Â plot.style_columns)  
`
In the script version below, we replaced the multiple str.startswith() calls with an expression containing a str.match() call. The call matches one of the supported exchange prefixes at the start of the string using the following regular expression:
```

^(?:BATS|NASDAQ|NYSE|AMEX):

```

We also replaced the str.pos() and str.substring() calls with a str.match() call. The call calculates the `noPrefix` value with a regex that matches all characters after the input valueâ€™s colon (`:`):
```

(?<=:).+

```

These changes achieve the same results as the previous script, but with more concise function calls:
Pine ScriptÂ®
Copied
`//@version=6  
indicator("MatchingÂ substringsÂ withÂ regexÂ demo")  
  
//@variableÂ TheÂ symbolÂ forÂ whichÂ toÂ requestÂ ShortÂ SaleÂ VolumeÂ data.Â   
stringÂ symbolInputÂ =Â input.symbol("NASDAQ:AAPL",Â "Symbol")  
  
//@variableÂ `true`Â ifÂ theÂ `symbolInput`Â startsÂ withÂ `BATS:`,Â `NASDAQ:`,Â `NYSE:`,Â orÂ `AMEX:`.Â Otherwise,Â `false`.  
//Â Â Â Â Â Â Â Â Â Â -Â `^`Â atÂ theÂ beginningÂ ofÂ theÂ regexÂ matchesÂ theÂ startÂ ofÂ theÂ string.  
//Â Â Â Â Â Â Â Â Â Â -Â `(?:...)`Â definesÂ aÂ non-capturingÂ group.  
//Â Â Â Â Â Â Â Â Â Â -Â `|`Â isÂ anÂ ORÂ operatorÂ thatÂ allowsÂ theÂ groupÂ toÂ matchÂ oneÂ ofÂ theÂ listedÂ options.Â   
varÂ boolÂ supportedSymbolÂ =Â str.match(symbolInput,Â "^(?:BATS|NASDAQ|NYSE|AMEX):")Â !=Â ""  
  
//@variableÂ TheÂ requestedÂ FINRAÂ dataÂ ifÂ `supportedSymbol`Â isÂ `true`,Â `na`Â otherwise.  
floatÂ requestedDataÂ =Â ifÂ supportedSymbol  
Â Â Â Â //@variableÂ TheÂ `symbolInput`Â valueÂ withoutÂ theÂ exchangeÂ prefix.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â -Â `(?<=:)`Â inÂ theÂ regexÂ isÂ aÂ lookbehindÂ assertionÂ thatÂ checksÂ ifÂ `:`Â precedesÂ theÂ match.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â -Â `.`Â matchesÂ anyÂ characterÂ exceptÂ forÂ lineÂ terminatorsÂ inÂ thisÂ context.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â -Â `+`Â isÂ aÂ quantifierÂ thatÂ specifiesÂ oneÂ orÂ moreÂ consecutiveÂ `.`Â matches.Â   
Â Â Â Â varÂ stringÂ noPrefixÂ =Â str.match(symbolInput,Â "(?<=:).+")  
Â Â Â Â //@variableÂ AÂ formattedÂ stringÂ representingÂ theÂ tickerÂ IDÂ ofÂ aÂ FINRAÂ ShortÂ SaleÂ VolumeÂ dataset.Â   
Â Â Â Â varÂ stringÂ finraTickerIDÂ =Â str.format("FINRA:{0}_SHORT_VOLUME",Â noPrefix)  
Â Â Â Â //Â LogÂ theÂ `finraTickerID`Â inÂ theÂ PineÂ LogsÂ paneÂ onÂ theÂ firstÂ bar.  
Â Â Â Â ifÂ barstate.isfirst  
Â Â Â Â Â Â Â Â log.info(finraTickerID)  
Â Â Â Â //Â RetrieveÂ theÂ data.Â   
Â Â Â Â request.security(finraTickerID,Â timeframe.isintradayÂ ?Â "1D"Â :Â "",Â close)  
  
//Â PlotÂ theÂ `requestedData`  
plot(requestedData,Â "ShortÂ SaleÂ Volume",Â color.teal,Â 1,Â plot.style_columns)  
`
Note that:
  * The caret (`^`) at the beginning of the regex string matches the _beginning_ of the `symbolInput`.
  * The `(?:...)` syntax in the regex string creates a _non-capturing group_.
  * The pipe character (`|`) in the regex acts as an _OR operator_. The group matches only _one_ of the character sequences separated by the character (`BATS`, `NASDAQ`, `NYSE`, or `AMEX`).
  * The `(?<=...)` syntax defines a _lookbehind assertion_ , which checks if the specified pattern precedes the match.
  * The `.` (period) character has a special meaning in regex strings. It matches _any_ character, excluding line terminators by default.
  * The `+` (plus sign) character is a _quantifier_. It specifies that the previous token (`.`) must match _one or more_ times.


The flexibility of regular expressions also allows str.match() to perform advanced matching tasks that are impractical or infeasible with other `str.*()` functions.
For instance, suppose we want to create a script that executes dynamic requests for a list of symbols specified in a text area input, and we require a specific input format consisting of only valid ticker patterns, comma separators with optional space characters, and no empty items. This validation is difficult to achieve with the other `str.*()` functions because they rely on _literal_ character sequences. However, with str.match(), we can define a single regular expression that matches the input only if it meets our required formatting criteria.
The script below demonstrates a single str.match() function call that validates the format of an input list of symbols. The user-defined `processList()` function combines strings to form the following regex for matching the `list` value:
```

^ *(?:(?:\w+:)?\w+(?:\.\w+){0,2}!? *, *)*(?:\w+:)?\w+(?:\.\w+){0,2}!? *$

```

If the str.match() call returns a _non-empty_ string, meaning the constructed pattern matches the `list` argument, the `processList()` function uses str.replace_all() to remove all space characters, then calls str.split() to split the string based on its commas to create an array of symbol substrings. Otherwise, it raises a runtime error with the runtime.error() function.
The script loops through the returned array of substrings to request data for each specified symbol and populate a table with the results:
!image
Pine ScriptÂ®
Copied
`//@version=6  
indicator("ProcessingÂ inputsÂ withÂ regexÂ demo")  
  
//@variableÂ AÂ stringÂ containingÂ aÂ listÂ ofÂ symbolsÂ separatedÂ byÂ commasÂ andÂ optionalÂ spaces.Â   
stringÂ listInputÂ =Â input.text_area("AMEX:SPY,Â AMEX:GLD,Â NASDAQ:TLT,Â CME:BTC1!,Â NYMEX:CL1!,Â TVC:US10Y",Â "SymbolÂ list")  
  
//@functionÂ ChecksÂ aÂ stringÂ valueÂ forÂ aÂ patternÂ ofÂ symbolsÂ separatedÂ byÂ commasÂ andÂ optionalÂ spaceÂ characters.Â   
//Â Â Â Â Â Â Â Â Â Â IfÂ theÂ specifiedÂ `list`Â doesÂ notÂ matchÂ thisÂ format,Â theÂ functionÂ raisesÂ aÂ runtimeÂ error.Â   
//Â Â Â Â Â Â Â Â Â Â Otherwise,Â itÂ returnsÂ anÂ arrayÂ ofÂ substringsÂ representingÂ eachÂ listedÂ symbol.Â   
processList(stringÂ list)Â =>  
Â Â Â Â //@variableÂ AÂ patternÂ forÂ anÂ optionalÂ groupÂ ofÂ oneÂ orÂ moreÂ wordÂ charactersÂ (`\w`Â class)Â followedÂ byÂ aÂ colonÂ (`:`).  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ patternÂ matchesÂ aÂ symbol'sÂ exchangeÂ prefix,Â ifÂ listedÂ   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â (e.g.,Â "NASDAQ:"Â forÂ "NASDAQ:AAPL"Â orÂ ""Â forÂ "AAPL").  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â `(?:...)`Â definesÂ aÂ non-capturingÂ group.Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â `\\w`Â isÂ anÂ ASCIIÂ digit,Â letter,Â orÂ lowÂ line.Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â TheÂ `+`Â meansÂ theÂ regexÂ checksÂ forÂ oneÂ orÂ moreÂ consecutiveÂ matchesÂ ofÂ theÂ previousÂ tokenÂ (`\w`).  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â TheÂ `?`Â atÂ theÂ endÂ makesÂ theÂ groupÂ optional.  
Â Â Â Â varÂ stringÂ exchangeÂ =Â "(?:\\w+:)?"  
  
Â Â Â Â //@variableÂ AÂ patternÂ forÂ 1+Â wordÂ characters,Â withÂ 0-2Â extraÂ wordÂ sequencesÂ dividedÂ byÂ `.`,Â thenÂ anÂ optionalÂ `!`.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â ThisÂ patternÂ matchesÂ symbolsÂ withoutÂ theÂ exchangeÂ prefix  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â (e.g.,Â "AAPL"Â forÂ "NASDAQ:AAPL",Â "BTC.D"Â forÂ "CRYPTOCAP:BTC.D",Â "ES1!"Â forÂ "CME_MINI:ES1!").  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â `\\w+`Â meansÂ oneÂ orÂ moreÂ wordÂ characters.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â `\\.`Â makesÂ theÂ `.`Â characterÂ literal.Â WhenÂ notÂ escaped,Â itÂ matchesÂ anyÂ character.Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â `{0,2}`Â meansÂ theÂ regexÂ matchesÂ theÂ group'sÂ patternÂ (`\.\w+`)Â zeroÂ toÂ twoÂ times.Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â TheÂ `?`Â makesÂ theÂ `!`Â characterÂ optional.Â   
Â Â Â Â varÂ stringÂ symbolÂ =Â "\\w+(?:\\.\\w+){0,2}!?"  
  
Â Â Â Â //@variableÂ AÂ patternÂ thatÂ matchesÂ aÂ symbolÂ orÂ comma-separatedÂ listÂ ofÂ symbolsÂ withÂ optionalÂ spaces.Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â (e.g.,Â "AAPL,Â OANDA:EURUSD,Â BATS:SPY,Â BINANCE:BTCUSDT.P")  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â `^`Â atÂ theÂ beginningÂ matchesÂ theÂ startÂ ofÂ theÂ textÂ line.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â `*`Â afterÂ theÂ spacesÂ andÂ groupÂ constructionÂ `(?:...)`Â meanÂ theÂ regexÂ matchesÂ themÂ zeroÂ orÂ moreÂ times.  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â Â -Â `$`Â atÂ theÂ endÂ matchesÂ theÂ endÂ ofÂ theÂ textÂ line.Â   
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â TheÂ formattedÂ resultÂ combinesÂ `exchange`Â andÂ `symbol`Â toÂ formÂ thisÂ regexÂ pattern:  
Â Â Â Â //Â Â Â Â Â Â Â Â Â Â `^Â *(?:(?:\w+:)?\w+(?:\.\w+){0,2}!?Â *,Â *)*(?:\w+:)?\w+(?:\.\w+){0,2}!?Â *$`  
Â Â Â Â varÂ stringÂ matchPatternÂ =Â str.format("^Â *(?:{0}{1}Â *,Â *)*{0}{1}Â *$",Â exchange,Â symbol)Â   
  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `list`Â ifÂ theÂ `matchPattern`Â producesÂ aÂ match.Â Otherwise,Â anÂ emptyÂ string.  
Â Â Â Â stringÂ matchÂ =Â str.match(list,Â matchPattern)  
  
Â Â Â Â //Â IfÂ theÂ `match`Â isÂ empty,Â meaningÂ theÂ `list`Â doesÂ notÂ haveÂ theÂ requiredÂ format,Â raiseÂ aÂ runtimeÂ error.  
Â Â Â Â ifÂ matchÂ ==Â ""  
Â Â Â Â Â Â Â Â runtime.error("InvalidÂ list.Â TheÂ valueÂ mustÂ representÂ aÂ comma-separatedÂ listÂ ofÂ symbolsÂ withÂ optionalÂ spaces.")  
  
Â Â Â Â //Â LogÂ anÂ `info`Â messageÂ showingÂ theÂ patternÂ andÂ theÂ match.Â Â   
Â Â Â Â log.info("\n\nTheÂ pattern:\n\n{0}\n\nmatches:\n\n{1}",Â matchPattern,Â match)Â Â Â Â   
  
Â Â Â Â //@variableÂ AÂ copyÂ ofÂ theÂ `match`Â withoutÂ spaceÂ characters.Â   
Â Â Â Â stringÂ noSpacesÂ =Â str.replace_all(match,Â "Â ",Â "")  
Â Â Â Â //@variableÂ AnÂ arrayÂ ofÂ substringsÂ formedÂ byÂ splittingÂ theÂ `noSpaces`Â valueÂ byÂ itsÂ commas.  
Â Â Â Â array<string>Â resultÂ =Â str.split(noSpaces,Â ",")  
  
//@variableÂ AnÂ arrayÂ ofÂ symbolsÂ fromÂ theÂ processedÂ `listInput`.Â   
varÂ array<string>Â symbolsÂ =Â processList(listInput)  
  
ifÂ barstate.islast  
Â Â Â Â //@variableÂ AÂ two-columnÂ tableÂ withÂ aÂ rowÂ forÂ eachÂ `symbols`Â item.Â   
Â Â Â Â varÂ tableÂ displayÂ =Â table.new(position.middle_center,Â 2,Â symbols.size())  
Â Â Â Â //Â LoopÂ throughÂ theÂ `symbols`Â array.Â   
Â Â Â Â forÂ [i,Â symbol]Â inÂ symbols  
Â Â Â Â Â Â Â Â //@variableÂ TheÂ `close`Â valueÂ requestedÂ forÂ theÂ `symbol`Â onÂ theÂ chart'sÂ timeframe.Â   
Â Â Â Â Â Â Â Â floatÂ requestedValueÂ =Â request.security(symbol,Â timeframe.period,Â close)  
Â Â Â Â Â Â Â Â //Â InitializeÂ aÂ cellÂ forÂ theÂ `symbol`Â andÂ aÂ stringÂ representingÂ theÂ `requestedValue`.Â   
Â Â Â Â Â Â Â Â display.cell(0,Â i,Â symbol,Â text_colorÂ =Â chart.fg_color,Â text_sizeÂ =Â 24)  
Â Â Â Â Â Â Â Â display.cell(1,Â i,Â str.tostring(requestedValue),Â text_colorÂ =Â chart.fg_color,Â text_sizeÂ =Â 24)  
`
Note that:
  * When creating regex strings, it is often helpful to display them in a scriptâ€™s text outputs to ensure they are formatted as intended. In this script, we included a log.info() call to show the resulting regular expression and its match in the Pine Logs pane.
  * Because the backslash (`\`) is an escape character in Pine strings, the value used as the `regex` argument in a str.match() call requires **two** consecutive backslashes for each single backslash in the regular expression.
  * The `\\w` parts of the regex string specify the `\w` pattern, a _predefined character class_ that matches _word characters_ (letters, digits, or low lines).
  * The `*` (asterisk) and `{0,2}` parts of the regular expression are _quantifiers_ , similar to `+`. The asterisk requires the previous token to match _zero or more_ times. The `{0,2}` quantifier requires the match to occur exactly _zero to two_ times.
  * The `$` (dollar sign) character in this regular expression matches the _end_ of the input, excluding any final line terminators (`\n`).
  * Because the `.` (period) character has a special meaning in regex strings, we must prefix it with two backslashes (`\\`) in the string to match a literal period.


#### Regex syntax reference
Every programming languageâ€™s regex engine has unique characteristics and syntax. Some regex syntax is universal across engines, while other patterns and modifiers are engine-specific.
The tables below provide a categorized overview of the syntax patterns supported by Pineâ€™s regex engine along with descriptions, remarks, and examples to explain how they work.
**Escapes and character references**
Click to show/hide Token/syntax | Description and remarks  
---|---  
`\` | Changes the meaning of the next character.  
  
Because Pine strings natively use `\` as an escape character, regex strings containing it must include an _additional_ `\` to use the token in the pattern. For example, `"\\"` represents a single `\` (escape token) in the regex, and `"\\\\"` represents `\\` (literal backslash).  
  
Some other characters always or conditionally represent regex syntax, including `.`, `^`, `$`, `*`, `+`, `?`, `(`, `)`, `[`, `]`, `{`, `}`, `|`, and `-`.  
To match a special character literally, include `"\\"` immediately before it in the string (e.g., `"\\+"` matches the literal `+` character).  
  
Note that some sequences of otherwise literal characters can also have syntactical meaning. See below for examples.  
`\Q...\E` | Matches everything between `\Q` and `\E` _literally_ , ignoring the syntactical meaning of special characters and sequences.  
  
For example, the regex string `"\\Q\\E"` matches the literal sequence of `[`, `^`, `a`, `b`, `c`, and `]` characters instead of creating a _character class_.  
`a` | Matches the literal character `a` (U+0061).  
  
By default, the regex engine is _case-sensitive_. If the string includes the `(?i)` modifier _before_ the token, the match becomes _case-insensitive_. For example, the regex string `"(?i)a"` matches the `a` or `A` character.  
`\t` | Matches the _tab space_ character (U+0009).  
`\n` | Matches the _newline_ character (U+000A).  
`\x61` | A _two-digit_ Unicode reference that matches the hexadecimal point U+0061 (the `a` character).  
  
This shorthand syntax works only for codes with leading zeros and up to **two** nonzero end digits. It cannot reference other Unicode points. For example, the regex string `"\\x2014"` matches U+0020 (the _space_ character) followed by U+0031 (the `1` character) and U+0034 (the `4` character). It **does not** match U+2014 (the `â€”` character).  
`\u2014` | A _four-digit_ Unicode reference that matches the hexadecimal point U+2014 (`â€”`, Em Dash).  
  
This syntax works only for codes with leading zeros and up to **four** nonzero end digits. It cannot reference larger Unicode points. For example, the regex string `"\\u1F5E0"` matches U+1F5E (unassigned) followed by U+0030 (the `0` character), resulting in no match. It **does not** match U+1F5E0 (the Stock Chart character).  
`\x{...}` | The _full-range_ Unicode reference syntax. The hexadecimal digits enclosed in the brackets can refer to _any_ Unicode point.  
  
Leading zeros in the digits _do not_ affect the matched Unicode point. For example, the regex strings `"\\x{61}"`, `"\\x{061}"`, `"\\x{0061}"`, and `"\\x{000061}"` all match U+0061 (the `a` character).  
**Character class and logical constructions**
Click to show/hide Token/syntax | Description and remarks  
---|---  
`[abc]` | A character class that matches only _one_ of the characters listed (`a`, `b`, or `c`). It does **not** match the _entire_ `abc` sequence.  
  
Each listed character, range, or nested class between two `[]` brackets represents a specific possible match.  
  
Note that several special characters have a _literal_ meaning inside classes (e.g., the regex string `"[.+$]"` matches `.`, `+`, or `$` literally). However, regex strings should still escape the following characters to treat them literally because they maintain a special meaning in most cases: `\`, `[`, `]`, `^`, `-`.  
`[a-z]` | A class that matches a single character in the _range_ from `a` (U+0061) to `z` (U+007A). It is equivalent to `[\x{61}-\x{7A}]`.  
  
Note that the left side of the `-` character must have a _smaller_ Unicode value than the right.  
For example, the regex string `"[f-a]"` is _invalid_ because `f` has the Unicode value U+0066, which is _larger_ than the value of `a`.  
  
If the dash (`-`) is at the start or end of the enclosed text, the regex treats it as a _literal_ character instead of a character range marker (e.g., `"[-abc]"` matches `-`, `a`, `b`, or `c` literally).  
`[a-zA-Z]` | A class containing a _list_ of character _ranges_. It matches any character from `a` (U+0061) to `z` (U+007A) or `A` (U+0041) to `Z` (U+005A) only.  
  
It is equivalent to `[\x{61}-\x{7A}\x{41}-\x{5A}]`.  
The syntax `[a-z[A-Z]]` also produces the same match.  
`` | The syntax for a class that matches any character _except_ for the ones specified.  
  
For example, the regex string `""` matches any character except for `a`, `b`, `c`, `\n` (newline), or   
  
Note that only a caret (`^`) at the _start_ of the enclosed text signifies _negation_. If the character comes after that point, the regex considers it a possible _literal_ match (e.g., `"[ab^c]"` matches the `a`, `b`, `^`, or `c` character literally).  
`[...&&[...]]` | The syntax for a nested class structure that matches any character within the _intersection_ of two character classes.  
  
Example 1: The regex string `"[abc&&[cde]]"` matches `c` exclusively because it is the only character common to both lists.  
  
Example 2: The regex string `"[a-z&&]"` matches any character from lowercase `a` to `z` except for `d`, `e`, or `f`.  
`expr1|expr2` | An OR operation that matches either the `expr1` or `expr2` substring. It does _not_ include both in the match.  
**Predefined classes**
Click to show/hide Token/syntax | Description and remarks  
---|---  
`.` | Matches any character on the line.  
  
By default, it _excludes_ line terminators (e.g., `\n`). To include line terminators in the match, add the `(?s)` modifier _before_ the token in the regex string (e.g., `"(?s)."`).  
`\d` | Matches a decimal digit character.  
  
By default, it is equivalent to `[0-9]`. However, if the regex string includes the `"(?U)"` modifier before the token, it can match _other_ Unicode characters with the â€œDigitâ€ property.  
  
For example, the string `"(?U)\\d"` can match characters such as U+FF11 (Fullwidth Digit One). In contrast, the only â€œDigit Oneâ€ character matched by the `[0-9]` class, even with the `(?U)` modifier, is U+0031 (the `1` character).  
`\D` | Matches a _non-digit_ character.  
  
By default, it is equivalent to ``, which does _not_ negate other Unicode digits. To exclude other Unicode digits from the match, include the `(?U)` modifier before the token in the regex string (e.g., `"(?U)\\D"`).  
`\w` | Matches a _word character_ (letter, digit, or low line).  
  
By default, it is equivalent to `[a-zA-Z0-9_]`, which excludes other Unicode characters. To include other Unicode letters, digits, or low lines in the match, add the `(?U)` modifier before the token in the regex string.  
For example, `"(?U)\\w"` can match characters such as U+FE4F (Wavy Low Line), whereas the only low line character the `[a-zA-Z0-9_]` class matches is U+005F (`_`).  
`\W` | Matches a _non-word_ character.  
  
By default, it is equivalent to ``, which does not negate other Unicode characters. To exclude other Unicode word characters from the match, include the `(?U)` modifier before the token (e.g., `"(?U)\\W"`).  
`\h` | Matches a _horizontal whitespace_ character, such as the tab space (`\t`), standard space, and other characters such as U+2003 (Em Space).  
  
The token matches other Unicode characters, even if the regex string includes the `(?-U)` modifier.  
`\H` | Matches a character that is _not_ a horizontal whitespace. It also excludes other Unicode spaces, even if the regex string includes the `(?-U)` modifier  
`\s` | Matches a _whitespace_ or other _control character_. In contrast to `\h`, this token covers a broader range of characters, including _vertical_ spaces such as `\n`.  
`\S` | Matches a _non-whitespace_ character. In contrast to `\H`, this token excludes a broader character range of characters from the match.  
**Unicode property classes**
Click to show/hide Token/syntax | Description and remarks  
---|---  
`\p{...}` | The syntax to match a Unicode point that has a specific property, such as script type), block, general category, etc. See the following rows to learn the required syntax for different common Unicode property references.  
  
To match any character that does _not_ have a specific Unicode property, use the _uppercase_ `P` in the syntax (`\P{...}`)  
`\p{IsScriptName}` or  
`\p{Script=ScriptName}` |  Unicode script#List_of_encoded_scripts) reference syntax. Matches any code point belonging to the `ScriptName` Unicode script. The specified name should not contain spaces.  
  
For example, the regex strings `"\\p{IsLatin}"` and `"\\p{Script=Latin}"` both match any Unicode point that is part of the Latin script.  
`\p{InBlockName}` or  
`\p{Block=BlockName}` |  Unicode block reference syntax. Matches any code point belonging to the `BlockName` Unicode block. The specified name should not contain spaces.  
  
For example, the regex string `"\\p{InBasicLatin}"` matches any Unicode point that is part of the Basic Latin) block, and `"\\p{Block=Latin-1Supplement}"` matches any point belonging to the Latin-1 Supplement block.  
`\p{category}` or  
`\p{gc=category}` | Unicode general category reference syntax. Matches any Unicode point with the assigned `category` _abbreviation_.  
  
For example, the regex string `"\\p{L}"` or `"\\p{gc=L}"` matches any Unicode point in the _Letter (L)_ category, and `"\\p{N}"` matches any point in the _Number (N)_ category.  
  
Note that, unlike some regex engines, Pineâ€™s regex engine does not support the _long form_ of a category name, (e.g., `"Letter"` instead of `"L"`).  
`\p{ClassName}` | The syntax for referencing the Unicode mapping of a POSIX character class, in Java notation.  
  
For example, the regex string `"\\p{XDigit}"` matches a _hexadecimal_ digit. By default, it is equivalent to `"[A-Fa-f0-9]"`.  
  
Note that the default behavior for POSIX classes matches only _ASCII_ characters. To allow other Unicode matches for a POSIX class, use the `(?U)` modifier. For instance, `"(?U)\\p{XDigit}"` can match non-ASCII characters that represent hexadecimal digits, such as U+1D7D9 (the `ğŸ™` character).  
**Group constructions**
Click to show/hide Token/syntax | Description and remarks  
---|---  
`(...)` | A _capturing group_ that matches the enclosed sequence and stores the matched substring for later reference.  
  
Each capturing group construction has an assigned _group number_ starting from 1. The regex can reference a capturing groupâ€™s match with the `\#` syntax, where `#` represents the group number.  
  
For example, the regex string `"(a|b)cde\\1"` matches `a` or `b`, followed by `cde`, and then another occurrence of the `(a|b)` groupâ€™s initial match. If the group matched `a`, the `\1` reference also matches `a`. If it matched `b`, the reference also matches `b`.  
  
If the regex does not need to use a groupâ€™s match later, using a _non-capturing_ group is the more efficient choice, e.g., `(?:...)`.  
`(?<name>...)` | A _named_ capturing group that matches the enclosed sequence and stores the matched substring with an assigned _identifier_.  
  
The regex can use the `\k<name>` syntax to reference the groupâ€™s match, where `name` is the assigned _identifier_. For example, the string `"(?<myGroup>a|b)cde\\k<myGroup>"` matches `a` or `b`, followed by `cde`, and then another instance of the substring (`a` or `b`) matched by the capturing group.  
  
As with a standard capturing group, a named capturing group contributes to the group count and has a _group number_ , meaning the regex can also reference a named group with the `\#` syntax, for example, `"(?<myGroup>a|b)cde\\1"`.  
`(?:...)` | A _non-capturing_ group that matches the enclosed sequence _without_ storing the matched substring. Unlike a capturing group, the regex string _cannot_ reference a previous non-capturing groupâ€™s match.  
  
For example, the regex string `"(?:a|b)\\1"` matches `a` or `b`, then references an _unassigned_ group match, resulting in _no match_.  
  
In contrast to all other group constructions, standard non-capturing groups can contain _pattern modifiers_ that apply exclusively to their scopes. For example, `"(?i)(?-i:a|b)c"` matches `a` or `b` followed by lowercase `c` or uppercase `C`. The `(?i)` part of the regex activates case-insensitive matching globally, but the `-i` token _deactivates_ the behavior for the groupâ€™s scope only.  
  
Note that non-capturing groups typically have a _lower_ computational cost than capturing groups.  
`(?>...)` | An _independent_ non-capturing group (_atomic group_). Unlike a standard non-capturing group, an atomic group consumes as many characters as possible _without_ allowing other parts of the pattern to use them.  
  
For example, the regex string `"(?s)(?>.+).+"` fails to produce a match because the atomic group `(?>.+)` consumes _every_ available character, leaving _nothing_ for the following `.+` portion to match.  
  
In contrast, the regex string `"(?s)(?:.+).+"` matches the entire source string because the standard non-capturing group `(?:.+)` _releases_ characters from its match as needed, allowing `.+` to match _at least one_ character.  
**Quantifiers**
Click to show/hide Token/syntax | Description and remarks  
---|---  
`?` | Appending `?` to a character, group, or class specifies that the matched substring must contain the pattern _once_ or _not at all_.  
  
For example, the regex string `"a?bc?"` matches `abc`, `ab`, `bc`, or `b` because `a` and `c` are _optional_.  
  
By default, regex quantifiers are _greedy_ , meaning they match as many characters as possible, releasing some as necessary. Adding `?` to another quantifier makes it _lazy_ , meaning it matches the _fewest_ characters possible, expanding its match only when required.  
  
For example, with a source string of `"a12b34b"`, the regex string `"a.*b"` matches the entire sequence, whereas `"a.*?b"` matches the _smallest_ valid substring with the pattern, which is `a12b`.  
`*` | Appending `*` to a character, group, or class specifies that the matched substring must contain the pattern _zero_ or _more_ times consecutively.  
  
For example, the regex string `"a*b"` matches zero or more consecutive `a` characters followed by a single `b` character.  
`+` | Appending `+` to a character, group, or class specifies that the matched substring must contain the pattern _one_ or _more_ times consecutively.  
  
For example, the regex string `"\\w+abc"` matches one or more consecutive word characters followed by `abc`.  
  
Adding `+` to another quantifier makes it _possessive_. Unlike a greedy quantifier (default), which _releases_ characters from the match as necessary, a possessive quantifier consumes as many characters as possible _without_ releasing them for use in other parts of the pattern.  
  
For instance, the regex string `"\\w++abc"` fails to produce a match because `\w++` consumes _all_ word characters in the pattern, including `a`, `b`, and `c`, leaving none for the `abc` portion to match.  
`{n}` | Appending `{n}` to a character, group, or class specifies that the matched substring must contain the pattern exactly `n` times consecutively, where `n` >= 0.  
  
For example, the regex string `"[abc]{2}"` matches two consecutive characters from the `[abc]` class, meaning the possible substrings are `aa`, `ab`, `ac`, `ba`, `bb`, `bc`, `ca`, `cb`, or `cc`.  
`{n,}` | Appending `{n,}` to a character, group, or class specifies that the matched substring must contain the pattern _at least_ `n` times consecutively, where `n` >= 0.  
  
For example, the regex string `"a{1,}b{2,}"` matches one or more consecutive `a` characters followed by two or more consecutive `b` characters.  
`{n, m}` | Appending `{n, m}` to a character, group, or class specifies that the matched substring must contain the pattern at least `n` times but no more than `m` times, where `n` >= 0, `m` >= 0, and `m` >= `n`.  
  
For example, the regex string `"\\w{1,5}b{2,4}"` matches one to five consecutive word characters followed by two to four repeated `b` characters.  
**Boundary assertions**
Click to show/hide Token/syntax | Description and remarks  
---|---  
`\A` | Matches the _starting point_ of the source string without consuming characters. It enables the regex to isolate the initial pattern in a string without allowing matches in other locations.  
  
For example, the regex string `"\\A\\w+"` matches a sequence of one or more word characters only if the sequence is at the start of the source string.  
`^` | When this character is outside a character class construction (i.e., ``), it matches the _starting point_ of a _line_ in the source string without consuming characters.  
  
By default, the character performs the same match as `\A`. However, if the regex string uses the `(?m)` modifier, it can also match a point immediately after a _newline_ character (`\n`).  
  
For example, the regex string `"(?m)^[xyz]"` matches `x`, `y`, or `z` if the character is at the start of the source string or immediately after the `\n` character.  
`\Z` | Matches the _ending point_ of the source string, or the point immediately before the final character if it is `\n`, without consuming characters. It enables the regex to isolate the final pattern in a string without allowing matches in other locations.  
  
For example, the regex string `"\\w+\\Z"` matches a sequence of one or more word characters only if the sequence is at the end of the source string or immediately before the final line terminator.  
`\z` | Matches the _absolute_ ending point of the source string without consuming characters. Unlike `\Z` (uppercase), this token does not match the point _before_ any final line terminator.  
  
For example, the regex string `"(?s)\\w+.*\\z"` matches a sequence of one or more word characters, followed by zero or more extra characters, only if the sequence is at the absolute end of the source string.  
`$` | Matches the _ending point_ of a _line_ in the source string without consuming characters.  
  
By default, it performs the same match as `\Z` (uppercase). However, if the regex string uses the `(?m)` modifier, it can match any point immediately before a newline (`\n`) character. For example, the regex string `"(?m)[123]$"` matches `1`, `2`, or `3` only if the character is at the end of the source string or immediately before the `\n` character.  
`\b` | Matches a _word boundary_ , which is the point immediately before or after a sequence of word characters (members of the `\w` class).  
  
For example, the regex string `"\\babc"` matches `abc` only if it is at the starting point of a word character sequence.  
`\B` | Matches a _non-word_ boundary, which is any point between characters that is _not_ the start or end of a word character sequence.  
  
For example, the regex string `"\\Babc"` matches `abc` only if it is not at the start of a word character sequence.  
**Lookahead and lookbehind assertions**
Click to show/hide Token/syntax | Description and remarks  
---|---  
`(?=...)` | A _positive lookahead_ assertion that checks whether the specified sequence immediately _follows_ the current match location, without consuming characters.  
  
For example, the regex string `"a(?=b)"` matches the `a` character only if `b` occurs immediately after that point, and it does not include `b` in the matched substring.  
`(?!...)` | A _negative lookahead_ assertion that checks whether the specified sequence _does not_ immediately follow the current match location, without consuming characters.  
  
For example, the regex string `"a(?!b)"` matches the `a` character only if the `b` character does not immediately follow it.  
`(?<=...)` | A _positive lookbehind_ assertion that checks whether the specified sequence immediately _precedes_ the current match location, without consuming characters.  
  
For example, the regex string `"(?<=a)b"` matches the `b` character only if the `a` character occurs immediately before that point, and it does not include `a` in the matched substring.  
`(?<!...)` | A _negative lookbehind_ assertion that checks whether the specified sequence _does not_ immediately precede the current match location, without consuming characters.  
  
For example, the regex string `"(?<!a)b"` matches the `b` character only if the `a` character does not immediately precede it.  
**Pattern modifiers**
Click to show/hide Token/syntax | Description and remarks  
---|---  
`(?...)` | This syntax applies a global list of inline _pattern modifiers_ (flags) to the regex string. Pattern modifiers change the matching behaviors of the regex engine. All parts of the regex string that come after this syntax update their behaviors based on the specified modifiers, and those behaviors persist from that point until explicitly overridden.  
  
For example, `"(?mi)"` activates _multiline_ and _case-insensitive_ modes for the rest of the regex string.  
  
To deactivate modifiers, include the `-` character before the list of modifier tokens. For instance, `"(?-mi)"` deactivates multiline and case-insensitive modes for the rest of the regex string.  
  
Standard _non-capturing groups_ can also utilize modifiers _locally_ , allowing different behaviors exclusively within group constructions.  
  
For example, `"(?U:\\d)123"` activates _Unicode-aware_ matching only for the specific group. The modifier does not apply globally, meaning the remaining `123` part of the regex string can only match _ASCII_ characters.  
  
See the rows below for details about the most common, useful pattern modifiers for Pine regex strings.  
`i` | The `i` character represents _case-insensitive_ mode when used as a global modifier (`(?i)`) or group modifier (`(?i:...)`).  
  
For example, the regex string `"a(?i)b(?-i)c"` matches lowercase `a`, uppercase `B` or lowercase `b`, and then lowercase `c`.  
  
Note that case-insensitive mode only applies to ASCII characters unless Unicode-aware mode is active.  
`m` | The m character represents multiline mode when used as a global modifier (`(?m)`) or group modifier (`(?m:...)`).  
  
By default, the `^` and `$` boundary assertions match the start and end of the source string, excluding final line terminators. With multiline mode enabled, they match the start and end boundaries of any _separate line_ in the string.  
  
For example, the regex string `"^abc"` matches `abc` only if the source string starts with that sequence, whereas `"(?m)^abc"` matches `abc` if it is at the start of the string or immediately follows a _newline character_ (`\n`).  
`s` | The lowercase `s` character represents _single-line mode_ (_dotall mode_) when used as a global modifier (`(?s)`) or group modifier (`(?s:...)`).  
  
By default, the `.` character matches any character except for line terminators such as `\n`. With single-line mode enabled, the regex treats the source string as _one line_ , allowing the character to match line terminators.  
  
For example, using the regex string `".+"` on the source string `"ab\nc"` matches `ab` only, whereas `"(?m).+"` matches the _entire_ source string.  
`U` | The uppercase `U` character represents _Unicode-aware_ mode when used as a global modifier (`(?U)`) or group modifier (`(?U:...)`).  
  
By default, most of the regex engineâ€™s predefined character classes and mapped POSIX classes do not match _non-ASCII_ characters. With Unicode-aware mode enabled, the regex allows these classes, and various ASCII character tokens, to match related Unicode characters.  
  
For example, the regex string `"\\d(?U)\\d+"` matches a single ASCII digit followed by one or more Unicode digit characters.  
`x` | The lowercase `x` character represents _verbose mode_ (_comments mode_) when used as a global modifier (`(?x)`) or group modifier (`(?x:...)`).  
  
In this mode, the regex string ignores _whitespace_ characters and treats sequences starting with `#` as _comments_.  
  
For example, the regex string `"(?x)[a-f ] 1 2\n3 # this is a comment!"` produces the same match as `"[a-f]123"`. It does **not** match the space or newline characters, or anything starting from the `#` character.  
  
Regex strings with this modifier can include multiple comments on _separate lines_ (e.g., `"a #match 'a' \nb #followed by 'b'"` matches `ab`).  
  
To match whitespaces or the `#` character in this mode, _escape_ them using backslashes or the `\Q...\E` syntax. For instance, `"(?x)\\#\\ \\# #comment"` and `"(?x)\\Q# #\\E #comment"` both literally match the sequence `# #`.  
 Previous   Next Time

## * Introduction
* Literal strings
  * Escape sequences
  * Concatenation
  * String conversion and formatting
  * Converting values to strings
  * Formatting strings
  * Custom representations
  * Modifying strings
  * Replacing substrings
  * Changing case
  * Trimming whitespaces
  * Repeating sequences
  * String inspection and extraction
  * Counting characters and substrings
  * Checking for substrings
  * Splitting strings
  * Locating and retrieving substrings
  * Matching patterns
  * Regex syntax reference


## Code Examples


```pine
str.tostring(value) â†’ string


str.tostring(value, format) â†’ string
```

```pine
str.format(formatString, arg0, arg1, ...) â†’ string
```

```pine
str.replace(source, target, replacement, occurrence) â†’ string


str.replace_all(source, target, replacement) â†’ string
```

```pine
str.upper(source) â†’ string


str.lower(source) â†’ string
```

```pine
str.trim(source) â†’ string
```

```pine
str.repeat(source, repeat, separator) â†’ string
```

```pine
str.length(string) â†’ int
```

```pine
str.contains(source, str) â†’ bool


str.startswith(source, str) â†’ bool


str.endswith(source, str) â†’ bool
```

```pine
str.split(string, separator) â†’ array<string>
```

```pine
str.pos(source, str) â†’ int
```

```pine
str.substring(source, begin_pos) â†’ string


str.substring(source, begin_pos, end_pos) â†’ string
```

```pine
str.match(source, regex) â†’ string
```

```pine
^(?:BATS|NASDAQ|NYSE|AMEX):
```

```pine
(?<=:).+
```

```pine
^ *(?:(?:\w+:)?\w+(?:\.\w+){0,2}!? *, *)*(?:\w+:)?\w+(?:\.\w+){0,2}!? *$
```